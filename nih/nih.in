#!/bin/sh

# Copyright (c) 2011, Aleksey Cheusov <vle@gmx.net>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials provided
#       with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

set -e 

export LC_ALL=C

usage (){
    cat 1>&2 <<'EOF'
Usage:
  pkgnih [global options] command [command options] [--] [command args]

Global options:
 nih -h              - Display help message
 nih -V              - Display nih version
 nih -y              - Answer 'Yes' to all questions
 nih -s <summary>    - pkg_summary(5) file

 nih -D              - enable debugging

Commands:
 nih <command> -h    - Display help message for a <command>
 nih help            - Display help message
 nih refresh         - Download pkg_summary and SHA512 files
 nih install
   nih update        - Install or update packages
 nih uninstall
   nih delete
   nih remove        - Uninstall packages
 nih verify          - Verify packages integrity
 nih status          - Show the status of installed packages
 nih search          - Search on packages
 nih audit           - Check the installed packages for vulnerabilities
 nih info            - Show information about package
 nih meta            - Output available or installed meta packages
 nih leaf            - Output or remove leaf packages
 nih list            - List packages
 nih mark            - Mark packages
 nih deps            - Show dependencies
 nih clean-cache     - Clean-up cache directory with binaries
 nih history         - Output a history of changes
EOF
}

sysconfdir=${NIH_SYSCONFDIR-@sysconfdir@}/nih
confdir=$HOME/.nih

dfltconfdir=${NIH_DFLTCONFDIR-@dfltconfdir@}

CACHEDIR=${CACHEDIR-@cachedir@}
PKG_INFO_CMD=${PKG_INFO_CMD-@PKG_INFO_CMD@}
PKG_ADMIN_CMD=${PKG_ADMIN_CMD-@PKG_ADMIN_CMD@}
PKG_DELETE_CMD=${PKG_DELETE_CMD-@PKG_DELETE_CMD@}
PKG_UPDATE_PLAN_CMD=${PKG_UPDATE_PLAN_CMD-pkg_update_plan}
PKG_ADD_CMD=${PKG_ADD_CMD-@PKG_ADD_CMD@}
SUFX=${SUFX-.tgz}

# loading config files
if test -r "$sysconfdir/config"; then
    conffile="$sysconfdir/config"
elif test -r "$confdir/config"; then
    conffile="$confdir/config"
else
    cat <<EOF
Neither $sysconfdir/config nor $confdir/config are readable.
Sorry, I cannot help.
EOF
    exit 1
fi

mkdir -p "$confdir"

. $dfltconfdir/nih.default.conf
. "$conffile"

# handling global options
process_options (){
    alt_getopt \
	h     'usage; exit 0' \
	V     'echo nih-@VERSION@; exit 0' \
	y     'always_yes=-y' \
	D     'debug=1' \
	=s    'summary=' \
	-- "$@"
}
cmds=`process_options "$@"`
eval "$cmds"

# temp directory
tmp_dir=`mktemp -d /tmp/nih.XXXXXX`
if test -z "$debug"; then
    trap "rm -rf $tmp_dir" 0 1 2 15
fi
test -n "$tmp_dir" || exit 1

#
if test $# -eq 0; then
    usage
    exit 1
fi

# -s
if test -n "$summary"; then
    case "$summary" in
	*.gz)
	    PKG_SUMMARY="$tmp_dir/pkg_summary.txt"
	    gzip -dc "$summary" > "$PKG_SUMMARY";;
	*.bz2)
	    PKG_SUMMARY="$tmp_dir/pkg_summary.txt"
	    bzip2 -dc "$summary" > "$PKG_SUMMARY";;
	*)
	    PKG_SUMMARY="$summary"
    esac
fi

######################################################################
######################################################################
######################################################################
# functions
format (){
    # $1 - indentation (a number of spaces)
    # $2 - max line size
    spcs="$1"
    shift
    maxsz="$1"
    shift

    runawk -v spcs="$spcs" -v maxsz="$maxsz" -e '
BEGIN {
   pad = ""
   for (i=1; i < spcs; ++i){ # spcs-1 spaces
      pad = pad " "
   }
   nl=1
}

{
   for (i=1; i <= NF; ++i){
      if (nl){
         printf "%s", pad
         nl = 0
         rest = maxsz
      }
      printf " %s", $i
      rest = rest - length($i) - 1
      if (rest < 0){
         nl = 1
         printf "\n"
      }
   }
}

END {
   if (!nl)
      printf "\n"
}
' "$@"
}

show_summary_PNC (){
    # PKGPATH <tab> (PKGNAME) <tab> COMMENT <nl>
    awk '/^PKGNAME=/ {pkgname=substr($0, 9)}
         /^PKGPATH=/ {pkgpath=substr($0, 9)}
         /^COMMENT=/ {comment=substr($0, 9)}
         NF == 0 {printf "%s\t%s\t%s\n", pkgpath, pkgname, comment}' "$@" |
    sort |
    awk -F'\t' '{printf "%s (%s)\n     %s\n", $1, $2, $3}'
}

show_summary_BC (){
    # PKGBASE     COMMENT <nl>
    awk '/^PKGNAME=/ {pkgbase=substr($0, 9); sub(/-[^-]*$/, "", pkgbase)}
         /^COMMENT=/ {comment=substr($0, 9)}
         NF == 0 {printf "%-19s %s\n", pkgbase, comment}' "$@" |
    sort
}

show_summary_NC (){
    # PKGNAME     COMMENT <nl>
    awk '/^PKGNAME=/ {pkgname=substr($0, 9)}
         /^COMMENT=/ {comment=substr($0, 9)}
         NF == 0 {printf "%-19s %s\n", pkgname, comment}' "$@" |
    sort
}

show_summary_N (){
    # PKGNAME
    awk '/^PKGNAME=/ {printf "%s ", substr($0, 9)}
	END {printf "\n"}' "$@" | wrap 70
}

show_summary_NP (){
    # PKGNAME(PKGNAME)
    awk '/^PKGNAME=/ {pkgname=substr($0, 9)}
         /^PKGPATH=/ {pkgpath=substr($0, 9)}
         NF == 0 {printf "%s (%s)  ", pkgname, pkgpath}
	END {printf "\n"}' "$@" | wrap 70
}

wrap (){ # fmt(1) is not portable accross different OSes
    w=$1
    shift
    awk -v w="$w" '
	{
	    for (i=1; i<=NF; ++i) {
		sz += length($i)+1
		if (i != 1 && sz > w){
		    sz = length($i)+1
		    printf "\n"
		}
		printf "%s ", $i
	    }
	} END {printf "\n"}' "$@"
}

indent (){
    awk '{print "    " $0}' "$@"
}

cleanup_db (){
    echo 'Updating pkgdb...' 1>&2
    $PKG_ADMIN_CMD rebuild-tree
}

yesno (){
    # $1 - id
    # $2 - question
    while true; do
	printf '%s (y/N)? ' "$2"
	set +e # workaround for buggy DragonFlyBSD/FreeBSD /bin/sh
	if test -n "$always_yes" || eval 'test -n "$yes_'"$1\""; then
	    echo Yes
	    set -e # workaround for buggy DragonFlyBSD/FreeBSD /bin/sh
	    return 0
	fi
	set -e # workaround for buggy DragonFlyBSD/FreeBSD /bin/sh

	read answer
	answer=${answer:-no}
	case "$answer" in
	    y|Y|yes|Yes|YES)
		return 0;;
	    n|N|no|No|NO)
		return 1;;
	esac
    done
}

verbose (){
    printf "%s\n" "$1"
}

get_date (){
    date +%Y%m%d_%H%M
}

summary2binary (){
    awk -v SUFX="$SUFX" '
    /^PKGNAME=/ {pkg1 = substr($0, 9) SUFX}
    /^FILE_NAME=/ {pkg2 = substr($0, 11)}
    NF == 0 {
	if (pkg2) print pkg2
	else print pkg1
	pkg1 = pkg2 = ""
    }' "$@"
}

# saves list of installed packages
save_installed_packages (){
    if test -n "$NO_INSTALLED_COPY"; then
	return
    fi

    installed_fn=$confdir/installed_`get_date`
    counter=''
    while test -f "${installed_fn}$counter.bz2"; do
	counter=${counter-0}
	counter=$(($counter+1))
    done

    installed_fn="${installed_fn}$counter.bz2"
    pkg_bin_summary -f \
	PKGNAME,PKGPATH,automatic,try_out,nih_hold,BUILD_DATE |
    bzip2 > "$installed_fn"
}

######################################################################
######################################################################
######################################################################
# help
if test "$1" = help; then
    usage
    exit 0
fi

######################################################################
######################################################################
######################################################################
# refresh
usage_refresh (){
    cat <<'EOF'
nih refresh [options]

      Download pkg_summary.bz2 and SHA512.bz2, save them to ~/.nih/, and
      then unpack them to .txt files.

   options:
      -h     display this help message

~/.nih/config:
   REPOSITORY - URL or file name for pkg_summary.bz2/pkg_summary.txt
   PKG_SUMMARY     - path to pkg_summary.txt, set this variable if you use
                   local pkg_summary, otherwise keep it unset
   fetch function  - download command
EOF
}

fetch_summary_file (){
    # $1 - extension
    echo "Downloading pkg_summary.$1..."
    if test -f pkg_summary.$1; then
	mv pkg_summary.$1 pkg_summary.$1.old
    fi
    if fetch "$REPOSITORY/All/pkg_summary.$1"; then
	case "$1" in
	    gz)  gzip -dc  pkg_summary.gz  > pkg_summary.txt.tmp || return 1;;
	    bz2) bzip2 -dc pkg_summary.bz2 > pkg_summary.txt.tmp || return 1;;
	    *)   echo 'Unknown ext'; exit 1;;
	esac
	mv pkg_summary.txt.tmp pkg_summary.txt
    else
	return 1
    fi
}

fetch_sha512_file (){
    # $1 - extension
    if test -n "$IGNORE_CKSUMS"; then
	return 0;
    fi

    echo "Downloading SHA512.$1..."
    if test -f SHA512.$1; then
	mv SHA512.$1 SHA512.$1.old
    fi
    if fetch "$REPOSITORY/SHA512.$1"; then
	echo done
	case "$1" in
	    gz)   gzip  -dc SHA512.$1 > SHA512.txt.tmp || return 1;;
	    bz2)  bzip2 -dc SHA512.$1 > SHA512.txt.tmp || return 1;;
	    *)   echo 'Unknown ext'; exit 1;;
	esac
	mv SHA512.txt.tmp SHA512.txt
    else
	return 1
    fi
}

if test "$1" = refresh; then
    shift
    while getopts h f; do
	case "$f" in
	    '?')
		exit 1;;
	    h)
		usage_refresh
		exit 0;;
	esac
    done
    shift `expr $OPTIND - 1`

    if test -n "$PKG_SUMMARY"; then
	cat 1>&2 <<EOF
Variable PKG_SUMMARY is set in configuration file.
Nothing to do.
EOF
	exit 1
    fi

    cd "$confdir"

    fetch=""

    if ! fetch_summary_file bz2 && ! fetch_summary_file gz; then
	echo 'pkg_summary(5) file cannot be downloaded.' 1>&2
	exit 1
    fi

    if ! fetch_sha512_file bz2 && ! fetch_sha512_file gz; then
	echo 'SHA512 file cannot be downloaded.' 1>&2
	exit 1
    fi

    if test -z "$NO_SUMMARY_COPY"; then
	date_sufx=`get_date`
	cp pkg_summary.txt pkg_summary_${date_sufx}.txt
	if test -z "$IGNORE_CKSUMS"; then
	    cp SHA512.txt SHA512_${date_sufx}.txt
	fi
    fi
    exit 0
fi

######################################################################
# ensure that pkg_summary.txt exists and refresh it
if test -z "$PKG_SUMMARY"; then
    if test -z "$IGNORE_CKSUMS"; then
	cksums=1 # checksums will be checked according to SHA512.txt
    fi
    PKG_SUMMARY=$confdir/pkg_summary.txt
fi

summary_exists (){
    if ! test -r "$PKG_SUMMARY"; then
	cat 1>&2 <<EOF
'$PKG_SUMMARY' file doesn't exist or is not readable.
Perhaps you need to run 'nih refresh'
EOF
	exit 1
    fi
}

refresh_summary (){
    summary_exists

    tiny_summary="$tmp_dir/tiny_summary"
    grep -E '^$|^(PKGNAME|PKGPATH|COMMENT|automatic|CONFLICTS|DEPENDS|BUILD_DATE|PROVIDES|REQUIRES|FILE_NAME)=' \
	"$PKG_SUMMARY" > "$tiny_summary" || true
    export PKG_SUMMARY="$tiny_summary"

    refreshed_summary="$tmp_dir/refreshed_summary"
    pkg_refresh_summary "$tiny_summary" > "$refreshed_summary"
}

######################################################################
######################################################################
######################################################################
# install | update
usage_install (){
    cat <<'EOF'
nih update  [options] <packages>
nih install [options] <packages>

      Install or update specified packages. These commands are the same.

   options:
      -h     display this help message

      -n     don't actually install a package, just report the steps that
             would be taken if it were.
      -d     download binaries only, do not install packages
      -B     consider packages different if their BUILD_DATE differ
      -l     do not remove auto-removable leaf packages
      -k     continue downloading packages after errors are encountered
      -t     install packages and mark them as "try out"
      -a <val>    set PKG_PATH and run pkg_add(8) directly
             val=1 ==> PKG_PATH=$CACHEDIR/All
             val=2 ==> PKG_PATH=$REPOSITORY/All

      -D     For debugging purposes

Packages may be specified as PKGBASE, PKGNAME, PKGPATH or a filename
with optional suffix `-' (marker for removal), `+' (marker for
auto-removable), or `_' (auto-removable flag will not be changed).
Packages without suffix will be marked as installed by user.
Marker `-' may be useful for resolving conflicts between installed
and new packages. Automatically installed leaf packages are removed
automatically.

Examples:
   nih update
   nih update -dk
   nih install mawk lang/gawk
   nih install perl
   nih install GConf+ xproto+
   nih install gmake- autoconf- automake- libtool-base-
   nih install textproc/dict-client wip/dict-client-
   nih install -t xfce4 fvwm openbox ctwm wmii fluxbox sawfish
   nih install -a1 firefox
   nih install -a2 -- -UA xulrunner
EOF
}

check_cksums (){
    # $1 - foobar-1.2.3.tgz
    if test -z "$cksums"; then
	return
    fi

    expected_sha512=`awk -v p="(All/$1)" '$2 == p {print $4}' $confdir/SHA512.txt`
    curr_sha512=`digest sha512 "$1" | awk '{print $4}'`
    if test "$expected_sha512" = "$curr_sha512"; then
	return 0
    else
	echo "$1 is corrupted, checksum mismatch"
	return 1
    fi
}

download_pkgs (){
    (
	cd "$CACHEDIR/All"
	ex=0
	while read pkg; do
	    if ! test -f "$pkg" || ! check_cksums "$pkg"; then
		echo "Downloading package $pkg..."
		if fetch "$REPOSITORY/All/$pkg" && check_cksums "$pkg"; then
		    :
		else
		    echo 'Checksum mismatch (nih refresh?)' 1>&2
		    if test "$force_download"; then
			ex=1
		    else
			exit 1
		    fi
		fi
	    fi
	done
	exit $ex
    )
}

grep_lines (){
    # $1 - file with lines
    awk 'FILENAME != "-" { hash [$0] = 0; next }
	($0 in hash) {print $0 }' "$1" -
}

rev_lines (){
    # $@ - files
    awk '{ line [NR] = $0 }
    END { for (i=NR; i >= 1; --i) print line [i] }' "$@"
}

if test "_$1" = _install -o "_$1" = _update; then
    cmd="$1"
    shift

    while getopts hndkBtDla: f; do
	case "$f" in
	    '?')
		exit 1;;
	    n)
		pkg_opts='-n';;
	    h)
		usage_install
		exit 0;;
	    d)
		download_only=1;;
	    k)
		export force_download=1;;
	    B)
		cmp_opts='-b';;
	    t)
		update_plan_opts="$update_plan_opts -t";;
	    l)
		update_plan_opts="$update_plan_opts -l";;
	    D)
		debug=1;;
	    a)
		pkg_add_local=$OPTARG;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    # -a
    if test -n "$pkg_add_local"; then
	echo "Installing packages $*" 1>&2
	save_installed_packages
	case "$pkg_add_local" in
	    1)
		export PKG_PATH=$CACHEDIR/All;;
	    2)
		export PKG_PATH=$REPOSITORY/All;;
	    *)
		echo 'Bad argument for -a option' 1>&2
		echo 'See nih install -h for details' 1>&2
		exit 1;;
	esac
	$PKG_ADD_CMD "$@"
	exit 0
    fi

    # 
    refresh_summary

    verbose "Getting a list of installed packages..."
    installed_summary="$tmp_dir/installed_summary"
    pkg_bin_summary \
	-fPROVIDES,REQUIRES,PKGNAME,PKGPATH,COMMENT,automatic,CONFLICTS,DEPENDS,BUILD_DATE,try_out \
	> "$installed_summary"

    cmp_summary="$tmp_dir/cmp_summary"

    update_pkgs_fn="$tmp_dir/pkgs_specs.txt"
    printf '' > "$update_pkgs_fn"
    if test $# -eq 0; then
	pkg_cmp_summary -p $cmp_opts "$installed_summary" "$refreshed_summary" \
	    > "$cmp_summary"
	awk '$1 ~ /^[<!]/ {
		print $3 "-"
		print $3 "-" $5 "_"
	}' "$cmp_summary" > "$update_pkgs_fn"
    else
	for i; do
	    if echo "$i" | grep '^/' > /dev/null; then
		suffix=`echo "$i" | sed -n 's|^.*\([-+_]\)$|\1|p'`
		if test -n "$suffix"; then
		    fn=`echo "$i" | sed 's|^\(.*\)[-+_]$|\1|'`
		else
		    fn="$i"
		fi
		pkg_info -X "$fn" |
		sed "s ^FILE_NAME=.*$ FILE_NAME=$fn " |
		tee "$tiny_summary".tmp |
		awk -v suffix="$suffix" '
		     /^PKGPATH=/ {p=substr($0, 9)}
		     /^PKGNAME=/ {n=substr($0, 9)}
		     END {print p ";" n suffix}' >> "$update_pkgs_fn"
		cat "$tiny_summary" >> "$tiny_summary".tmp
		pkg_uniq_summary "$tiny_summary".tmp > "$tiny_summary"
	    else
		printf '%s\n' "$i" >> "$update_pkgs_fn"
	    fi
	done
    fi

    ##################################################################
    ######################### update plan ############################
    verbose "Generating an update plan..."
    plan_summary="$tmp_dir/plan_summary"
    printf '' > "$plan_summary"
    if ! test -s "$update_pkgs_fn"; then
	echo 'Everything is up-to-date.'
	exit 0
    fi

    if test -n "$debug"; then
	debug_opt=-v
    fi

    if ! $PKG_UPDATE_PLAN_CMD -iv $update_plan_opts $debug_opt \
	"$installed_summary" "$PKG_SUMMARY" \
	> "$plan_summary" < "$update_pkgs_fn"
    then
	cat "$plan_summary" 1>&2
	exit 1
    fi

    pkg_cmp_summary $cmp_opts "$installed_summary" "$plan_summary" \
	> "$cmp_summary" || true

    pkg_grep_summary -s force_update yes < "$plan_summary" |
    awk '/^PKGNAME=/ {
	base = ver = substr($0, 9)
	sub(/-[^-]*$/, "", base)
	sub(/^.*-/, "", ver)
	printf "! %s x %s\n", base, ver}' >> "$cmp_summary"

    printf '%s\n' '---------------------- UPDATE PLAN -------------------------'

    rem_pkgs=`awk '$1 == "-" {print $2}' "$cmp_summary"`
    rem_pkgs=`echo $rem_pkgs` # remove NL characters
    rem_summary="$tmp_dir/rem_summary"
    pkg_grep_summary -t strlist PKGBASE "$rem_pkgs" \
	< "$installed_summary" > "$rem_summary"

    inst_pkgs=`awk '$1 ~ /^[<>!]$/ {print $2 "-" $4}
                    $1 ~ /^[+]$/   {print $2 "-" $3}' "$cmp_summary" | sort -u`
    inst_pkgs=`echo $inst_pkgs`

    auto_pkgs=`pkg_grep_summary -v -e automatic < "$plan_summary" |
	sed -n 's/^PKGNAME=//p'`
    auto_pkgs=`echo $auto_pkgs`

    inst_auto_summary="$tmp_dir/inst_auto_summary"
    pkg_grep_summary -t strlist PKGNAME "$inst_pkgs" < "$plan_summary" |
    pkg_grep_summary -t strlist PKGNAME "$auto_pkgs" > "$inst_auto_summary"

    inst_summary="$tmp_dir/inst_summary"
    pkg_grep_summary -t strlist PKGNAME "$inst_pkgs" < "$plan_summary" |
    pkg_grep_summary -v -t strlist PKGNAME "$auto_pkgs" > "$inst_summary"

    conflicts_msg="$tmp_dir/conflicts"
    extra_rem_pkgs="$tmp_dir/extra_rem"
    extra_rem_summary="$tmp_dir/extra_rem_summary"
    printf '' > "$extra_rem_summary"
    if ! pkg_lint_summary -c "$inst_summary" "$inst_auto_summary" \
	"$installed_summary" > "$conflicts_msg"
    then
	awk '$1 == "c:" {print $5; print $8}
	     $1 == "d:" {print $6}' "$conflicts_msg" |
	sort -u > "$extra_rem_pkgs"
	pkg_grep_summary -t strfile PKGNAME "$extra_rem_pkgs" \
	    < "$installed_summary" > "$extra_rem_summary"
    fi

    # rem
    if test -s "$rem_summary" -o -s "$extra_rem_summary"; then
	echo 'The following packages will be removed'
	summary2packages_to_be_removed "$rem_summary"
	if test -s "$extra_rem_summary"; then
	    echo '    //'
	    summary2packages_to_be_removed "$extra_rem_summary"
	fi
    fi

    # install
    if test -s "$inst_summary"; then
	echo 'The following packages will be installed'
	summary2packages_to_be_installed "$inst_summary"
    fi

    # install as a depdendency
    if test -s "$inst_auto_summary"; then
	echo 'The following packages will be installed as auto-removable'
	summary2packages_to_be_installed_as_dep "$inst_auto_summary"
    fi

    #
    if ! yesno install 'Proceed'; then
	exit 0
    fi

    ##################################################################
    ########################## installing ############################
    summary2binary "$inst_summary" "$inst_auto_summary" |
    grep -v '^[/.]' |
    download_pkgs

    if test -n "$download_only"; then
	exit 0
    fi

    cd $CACHEDIR/All

    # Ensure that packages that will be be installed do not have
    # common files
    if test -z "$NO_PLIST_CHECK" -a -n "$inst_pkgs"; then
	echo "Checking packages from update plan for common files..." 1>&2
	plist_summary="$tmp_dir/plist_summary"

	{
	    # packages to install
	    for i in $inst_pkgs; do
		echo "./$i$SUFX"
	    done | 
	    xargs pkg_bin_summary -e -f PKGNAME,PKGPATH,PLIST

	    # remained packages
	    awk '/^[=]/ {print $2}' "$cmp_summary" |
	    xargs pkg_bin_summary -e -f PKGNAME,PKGPATH,PLIST
	} | pkg_uniq_summary -n > "$plist_summary"

	if ! pkg_lint_summary -f "$plist_summary"; then
	    exit 1
	fi
    fi

    # installation
    save_installed_packages

    if test -s "$rem_summary" -o -s "$extra_rem_summary"; then
	sed -n 's/^PKGNAME=//p' "$rem_summary" "$extra_rem_summary" \
	    > "$extra_rem_pkgs"
	pkg_summary2deps -drt "$installed_summary" | tsort |
	grep_lines "$extra_rem_pkgs" - | rev_lines |
	while read pkg; do
	    echo "Removing package $pkg..." 1>&2
	    $PKG_DELETE_CMD -f $pkg_opts "$pkg"
	done
    fi

    pkg_summary2deps -ndtr "$plan_summary" | tsort |
    while read pkg; do
	fn_auto_pkg=`pkg_grep_summary -r -s PKGNAME "$pkg" < "$inst_auto_summary" | summary2binary`
	fn_pkg=`pkg_grep_summary -r -s PKGNAME "$pkg" < "$inst_summary" | summary2binary`
	if test -n "$fn_auto_pkg"; then
	    echo "Installing package $pkg as a dependency..." 1>&2
	    if ! $PKG_ADD_CMD $pkg_opts -UDA "$fn_auto_pkg"; then
		cleanup_db; exit 1
	    fi
	elif test -n "$fn_pkg"; then
	    echo "Installing package $pkg..." 1>&2
	    if ! $PKG_ADD_CMD $pkg_opts -UD "$fn_pkg"; then
		cleanup_db; exit 1
	    fi
	fi
    done

    ##################################################################
    ###### Marking packages that were not installed or updated #######
    echo "Updating installed information..." 1>&2
    awk -v auto=0 -v try_out=0 '
	FILENAME != "-" && $0 ~ /^PKGNAME=/ {pkgname = substr($0, 9)}
	FILENAME != "-" && $0 ~ /^automatic/ {auto = 1}
	FILENAME != "-" && NF == 0 {automatic_o [pkgname] = auto; auto = 0}
	FILENAME != "-" && $0 ~ /^try_out/ {try_out = 1}
	FILENAME != "-" && NF == 0 {try_out_o [pkgname] = try_out; try_out = 0}
	FILENAME == "-" && $0 ~ /^PKGNAME=/ {pkgname = substr($0, 9)}
	FILENAME == "-" && $0 ~ /^automatic/ {auto = 1}
	FILENAME == "-" && NF == 0 {automatic_n [pkgname] = auto; auto = 0}
	FILENAME == "-" && $0 ~ /^try_out/ {try_out = 1}
	FILENAME == "-" && NF == 0 {try_out_n [pkgname] = try_out; try_out = 0}
	END {
	    for (i in automatic_n)
		if ((i in automatic_o) && automatic_o [i] != automatic_n [i])
		    print i, "automatic", automatic_n [i]
	    for (i in try_out_n)
		if (try_out_n [i] || try_out_o [i])
		    print i, "try_out", 1
	}' "$installed_summary" - < "$plan_summary" |
    while read pkg marker m; do
	if test "$m" -eq 0; then
	    echo "Marking $pkg as installed by user"
	    if test -z "$pkg_opts"; then
		$PKG_ADMIN_CMD unset "$marker" "$pkg"
	    else
		echo '   skipped'
	    fi
	else
	    echo "Marking $pkg as \"try_out\""
	    if test -z "$pkg_opts"; then
		$PKG_ADMIN_CMD set "$marker"=yes "$pkg"
	    else
		echo '   skipped'
	    fi
	fi
    done

    cleanup_db

    exit 0
fi

######################################################################
######################################################################
######################################################################
# uninstall | remove | delete
usage_uninstall (){
    cat <<'EOF'
nih uninstall <PKGBASEs>
nih delete    <PKGBASEs>
nih remove    <PKGBASEs>

      Remove specified packages, dependent packages and automatically installed
      leaf packages. These three command are the same.

   options:
      -h     display this help message
      -n     don't actually deinstall a package, just report the steps that
             would be taken if it were.
      -l     do not remove auto-removable leaf packages
      -t     remove "try out" packages
Examples:
   nih uninstall libgnome python26 kdelibs4
EOF
}

if test "_$1" = _uninstall -o "_$1" = _remove -o "_$1" = _delete; then
    shift
    while getopts hnlt f; do
	case "$f" in
	    '?')
		exit 1;;
	    n|l)
		pkg_delete_opts="$pkg_delete_opts -$f";;
	    h)
		usage_uninstall
		exit 0;;
	    t)
		try_out=1;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    if test -n "$try_out"; then
	tryout_pkgs="$tmp_dir/tryout"
	pkg_bin_summary -f PKGNAME,try_out |
	pkg_grep_summary -s try_out yes |
	awk '/^PKGNAME=/ {print substr($0, 9) "--"}' > "$tryout_pkgs"
	plan=`cat "$tryout_pkgs"`
    fi

    for i in "$@"; do
	plan="$plan $i--"
    done

    if test -z "$plan"; then
	echo 'No packages to be removed.' 1>&2
	exit 1
    fi

    $0 $always_yes install $pkg_delete_opts $plan

    exit 0
fi

######################################################################
######################################################################
######################################################################
# verify
usage_verify (){
    cat <<'EOF'
nih verify -h
nih verify -d|-c|-l|-L
nih verify -m|-s [PKGBASEs]

      Verify installed or listed packages.
      By default all installed packages are verified.

   options:
       -h     display this help message
       -m     check the checksums of installed files
       -l|-U  check the REQUIRES/PROVIDES coherence
       -L     check the existence of library files listed in REQUIRES
       -d     check the presence of dependencies
       -c     check the conflicts
       -s     compare `uname -r` and OS_VERSION from PKGBASEs
Examples:
   nih verify -dclL
   nih verify -m
   nih verify -m 'lib*' gawk
   nih verify -s
EOF
}

if test "$1" = verify; then
    shift
    opts='k'
    while getopts hmUlLdcs f; do
	case "$f" in
	    '?')
		exit 1;;
	    h)
		usage_verify
		exit 0;;
	    l)
		opts="${opts}U";;
	    s)
		opts="${opts}S";;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    if test k = "$opts"; then
	usage_verify
	exit 1
    fi

    pkg_status "-$opts" "$@"

    exit 0
fi

######################################################################
######################################################################
######################################################################
# status
usage_status (){
    cat <<'EOF'
nih status [options] [PKGBASEs]

      Compare installed packages with pkg_summary.txt (default) or
      pkgsrc tree.

   options:
      -h     display this help message
      -b     compare installed packages against pkg_summary.txt (default)
      -s     compare installed packages against pkgsrc tree
      -r     raw output (pkg_summary format)
      -u     analyse packages marked as installed by user (the default, see -a)
      -a     analyse all packages (see -u)
      -B     consider packages different if their BUILD_DATE differ
      -A     by default up-to-date packages are skipped,
             with -A they are output too
      -q     no noisy reminder about output format

Examples:
   nih status -a
   nih status -uq
   nih status -sqr pkglint
EOF
}

if test "$1" = status; then
    shift
    opts='b'
    while getopts hbsruaqAB f; do
	case "$f" in
	    '?')
		exit 1;;
	    h)
		usage_status
		exit 0;;
	    a)
		opts="${opts}aT";;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    if echo "$opts" | grep 'b[^s]*$' > /dev/null; then
	refresh_summary
    fi

    pkg_status "-$opts" "$@"

    exit 0
fi

######################################################################
######################################################################
######################################################################
# search
usage_search (){
    cat <<'EOF'
nih search [options] [args]

      Search for packages

   options:
      -h    display this help message

      -b    search in pkg_summary.txt (the default)
      -o    search using pkg_online
      -I    search in installed packages

      -s    output search strategies
      -f    output search fields
      -1    display 1-line information about packages (default)
      -3    display short information about packages
      -9    display full information about packages
      -r    raw summaries are output
      -q    quiet mode, do not print "No matches found" to stderr

See pkg_digger(1) for details.

Examples:
   nih search -h
   nih search -s
   nih search -f
   nih search DEPENDS:substring:libmaa
   nih search PKGNAME:prefix:dict
   nih search COMMENT:word:dns PKGPATH:prefix:net
   nih search c:kw:'dns server'
   nih search n:p:lua
   nih search FILE_SIZE:awk:'fvalue+0 > 100000000'
   nih search -9 lang/mawk
   nih search -os
   nih search -of
   nih search -o oberon
   nih search -o dns server
   nih search -o3 dictionary -spell -japanese -chinese -korean
   nih search -o -q9r spreadsheet
EOF
}

# info
usage_info (){
    cat <<'EOF'
nih info [options] PKGBASE [PKGBASEs...]

      Show information about packages

   options:
      -h    display this help message

      -b    search in pkg_summary.txt (the default)
      -o    search using pkg_online
      -I    search in installed packages

      -r    raw summaries are output
      -q    quiet mode, do not print "No matches found" to stderr

See pkg_digger(1) for details.

Examples:
   nih info -h
   nih info runawk
   nih info -I runawk
   nih info -o oberon
EOF
}

# meta
usage_meta (){
    cat <<'EOF'
nih meta [options]

      List meta packages

   options:
      -h    display this help message

      -b    search in pkg_summary.txt (the default)
      -o    search using pkg_online
      -I    search in installed packages

      -r    raw summaries are output
      -q    quiet mode, do not print "No matches found" to stderr

See pkg_digger(1) for details.

Examples:
   nih meta -h
   nih meta
   nih meta -Ir
   nih meta -o
EOF
}

if test "_$1" = _search -o "_$1" = _info -o "_$1" = _meta; then
    op="$1"
    shift
    export PKG_DIGGER_SUMMARY="$PKG_SUMMARY"

    while getopts hboIsf139rq f; do
	case "$f" in
	    '?')
		exit 1;;
	    b)
		unset PKG_DIGGER_BACKEND || true
		unset in_installed || true;;
	    o)
		export PKG_DIGGER_BACKEND=pkg_online_client
		unset in_installed || true;;
	    I)
		unset PKG_DIGGER_BACKEND || true
		in_installed=1;;
	    r)
		raw=1
		opts="${opts}r";;
	    h)
		usage_$op
		exit 0;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    if test -n "$in_installed"; then
	export PKG_DIGGER_SUMMARY="$tmp_dir/installed_summary"
	pkg_bin_summary -a automatic > "$PKG_DIGGER_SUMMARY"
    fi

    if test "$PKG_DIGGER_SUMMARY" = "$PKG_SUMMARY" -a \
	"$PKG_DIGGER_BACKEND" = ''
    then
	summary_exists
    fi

    case "$op" in
	info)
	    if test $# -eq 0; then
		echo 'No packages were specified'
		usage_info
		exit 1
	    fi

	    for i in "$@"; do
		pkg_digger -9 ${opts+-$opts} PKGBASE:exact:"$i"
	    done;;
	meta)
	    pkg_digger -3r ${opts+-$opts} CATEGORIES:word:meta-pkgs |
	    if test -n "$raw"; then
		cat
	    else
		summary2meta_packages
	    fi;;
	*)
	    pkg_digger ${opts+-$opts} "$@";;
    esac

    exit 0
fi

######################################################################
######################################################################
######################################################################
# leaf
usage_leaf (){
    cat <<'EOF'
nih leaf [options]

      Output or remove automatically installed leaf packages,
      by default list of leaves is output.

   options:
      -h    display this help message
      -t    output only PKGNAME
      -R    remove automatically installed leaf packages
      -n    pass -n to pkg_delete

Examples:
   nih leaf -t
   nih leaf -R
   nih leaf -Rn
EOF
}

if test "$1" = leaf; then
    shift
    opts='l'
    while getopts htRn f; do
	case "$f" in
	    '?')
		exit 1;;
	    h)
		usage_leaf
		exit 0;;
	    R)
		remove=1;;
	    *)
		pkg_delete_opts=-n
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    if echo "$opts" | awk 'BEGIN { exit (!/[RE]/ || /n/) }' > /dev/null; then
	save_installed_packages
    fi

    if test -n "$remove"; then
	rem_pkgnames="$tmp_dir/rem_pkgnames"
	rem_summary="$tmp_dir/rem_summary"

	pkg_status -lt > "$rem_pkgnames"

	if test -s "$rem_pkgnames"; then
	    echo 'The following packages will be removed'
	    xargs pkg_bin_summary -e < "$rem_pkgnames" > "$rem_summary"
	    summary2packages_to_be_removed "$rem_summary"

	    if ! yesno remove_pkgs 'Proceed'; then
		exit 0
	    fi

	    save_installed_packages
	    xargs $PKG_DELETE_CMD $pkg_delete_opts < "$rem_pkgnames"
	fi
    else
	pkg_status "-$opts" "$@"
    fi

    exit 0
fi

######################################################################
######################################################################
######################################################################
# list
usage_list (){
    cat <<'EOF'
nih list [options]

      Output available or installed packages.

   options:
      -h       display this help message

      -b       output packages from binary repository (the default)
      -a|-I    output all installed packages
      -u       output packages installed by user
      -t       output installed packages marked as "try out"

      -r       output raw summaries

Examples:
   nih list -h
   nih list
   nih list -t
   nih list -ur
EOF
}

if test "$1" = list; then
    shift
    while getopts hbauIrt f; do
	case "$f" in
	    '?')
		exit 1;;
	    h)
		usage_list
		exit 0;;
	    b)
		info_opts='';;
	    t)
		info_opts='a'
		try_out=1;;
	    I)
		info_opts="${info_opts}a";;
	    a|u)
		info_opts="${info_opts}$f";;
	    r)
		raw=1;;
	esac
    done
    shift `expr $OPTIND - 1`

    if test -n "$info_opts"; then
	pkg_bin_summary -a automatic,try_out -- "-$info_opts" |
	if test -n "$try_out"; then
	    pkg_grep_summary -s try_out yes
	else
	    cat
	fi |
	if test -n "$raw"; then
	    cat
	else
	    summary2installed_packages
	fi
    else
	if test -n "$raw"; then
	    cat "$PKG_SUMMARY"
	else
	    summary2available_packages "$PKG_SUMMARY"
	fi
    fi

    exit 0
fi

######################################################################
######################################################################
######################################################################
# mark
usage_mark (){
    cat <<'EOF'
nih mark [options] PKGBASEs

      Mark packages

   options:
      -h       display this help message
      -u/-U    mark/unmark packages as "installed by user"
      -a/-A    mark/unmark packages as "installed as a dependency"
      -t/-T    mark/unmark packages as "try out"

NOTES:
   -a and -U are synonyms
   -u and -A are synonyms
Examples:
   nih mark -a libmaa
   nih mark -u ffmpeg
   nih mark -t wmii openbox fluxfox sawfish xfce4
   nih mark -T ctwm
EOF
}

if test "$1" = mark; then
    shift
    opts='l'
    while getopts huUaAtT f; do
	case "$f" in
	    '?')
		exit 1;;
	    h)
		usage_mark
		exit 0;;
	    u|A)
		mode_u=1;;
	    a|U)
		mode_a=1;;
	    t)
		mode_t=1;;
	    T)
		mode_T=1;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    if test -z "$mode_u$mode_a$mode_t$mode_T"; then
	pkg_bin_summary -e -a try_out,nih_hold,automatic "$@" |
	summary2markers
	exit 0
    elif test "$mode_u$mode_a$mode_t$mode_T" != 1; then
	echo 'Only one option is allowed' 1>&2
	exit 1
    elif test -n "$mode_a"; then
	cmd='set automatic=yes'
    elif test -n "$mode_u"; then
	cmd='unset automatic'
    elif test -n "$mode_t"; then
	cmd='set try_out=yes'
    elif test -n "$mode_T"; then
	cmd='unset try_out'
    fi

    if test $# -eq 0; then
	echo 'No packages were specified' 1>&2
	exit 
    fi

    save_installed_packages
    $PKG_ADMIN_CMD $cmd "$@"
    exit 0
fi

######################################################################
######################################################################
######################################################################
# deps
usage_deps (){
    cat <<'EOF'
nih deps [options] [pkgs...]

      Output a dependency graph of installed packages or remote summary.

   options:
      -h    display this help message
      -r    output dependencies, by default packages
            that depend on "pkgs" are output.
      -l    output list of packages instead of graph
      -B    output PKGBASE (the default)
      -P    output PKGPATH
      -N    output PKGNAME
      -t    output dependencies in tsort(1) compatible format
      -I    analyse installed packages
If both -P and -N are applied, PKGPATH;PKGNAME is output,
if both -P and -B are applied, PKGPATH;PKGBASE is output.

Examples:
   nih deps
   nih deps -P
   nih deps -PB
   nih deps glib2
   nih deps -r glib2
   nih deps -rI pkgnih
   nih deps -lBP 'devel/glib2;glib2' 'devel/libmaa;libmaa'
   nih deps -P devel/glib2 devel/libmaa
EOF
}

if test "$1" = deps; then
    shift
    sb_opts=''
    pn_opts=''
    while getopts hrlBNPtI f; do
	case "$f" in
	    '?')
		exit 1;;
	    h)
		usage_deps
		exit 0;;
	    r)
		sb_opts="$sb_opts -r";;
	    l)
		sb_opts="$sb_opts -n";;
	    t)
		pn_opts="$pn_opts -t";;
	    B)
		pn_opts="$pn_opts -n";;
	    N)
		pn_opts="$pn_opts -nr";;
	    P)
		pn_opts="$pn_opts -p";;
	    I)
		installed_summary=1;;
	esac
    done
    shift `expr $OPTIND - 1`

    pn_opts=${pn_opts:--n}

    if test -n "$installed_summary"; then
	pkg_bin_summary -fPKGNAME,PKGPATH,DEPENDS
    else
	summary_exists
	cat "$PKG_SUMMARY"
    fi |
    pkg_summary2deps -d $pn_opts 2>/dev/null |
    if test $# -eq 0; then
	sort -u
    else
	pkg_subgraph_deps $sb_opts -p "$*" | sort -u
    fi
    exit 0
fi

######################################################################
######################################################################
######################################################################
# clean-cache
usage_clean_cache (){
    cat <<'EOF'
nih clean-cache [options] [pkgs...]

      Delete binaries in cache directory. By default all binaries
      except those of installed packages are removed.

   options:
      -h    display this help message
      -n    output files to be removed
      -a    remove all binaries
      -i    binaries for packages listed in ~/.nih/installed_*
            are not removed.

Examples:
   nih clean-cache
   nih clean-cache -n
   nih clean-cache -a
EOF
}

if test "$1" = clean-cache; then
    shift
    while getopts hnai f; do
	case "$f" in
	    '?')
		exit 1;;
	    h)
		usage_clean_cache
		exit 0;;
	    n)
		noop=1;;
	    a)
		rem_all=1;;
	    i)
		keep_installed=1;;
	esac
    done
    shift `expr $OPTIND - 1`

    cd $CACHEDIR/All

    present=$tmp_dir/present
    installed=$tmp_dir/installed
    del=$tmp_dir/del

    if test -n "$rem_all"; then
	printf '' > "$installed"
    else
	{
	    pkg_info -Xa

	    if test -n "$keep_installed"; then
		find "$confdir" -name 'installed_*.txt' | xargs cat
		find "$confdir" -name 'installed_*.bz2' | xargs bzip2 -dc
	    fi
	} | summary2binary | sort -u > "$installed"
    fi

    ls -1 | grep "$SUFX"'$' | sort > "$present"

    comm -13 "$installed" "$present" > "$del"
    if test -s "$del"; then
	echo 'The following files will be deleted'
	indent "$del"
	if test -n "$noop" || ! yesno remove_pkgs 'Proceed'; then
	    exit 0
	fi

	xargs rm -f < "$del"
    else
	echo 'The are no binaries to remove'
	exit 0
    fi

    exit 0
fi

######################################################################
######################################################################
######################################################################
# audit
usage_audit (){
    cat <<'EOF'
nih audit [options] [pkgs...]

      Download a new pkg-vulnerabilities file and check the listed
      installed packages for vulnerabilities. If no package is given,
      check all installed packages.

   options:
      -h    display this help message
      -d    download a new pkg-vulnerabilities file,
            do not check packages
      -c    check the packages for vulnerabilities
            using existing pkg-vulnerabilities file

Examples:
   nih audit -h
   nih audit
   nih audit -d
   nih audit -c 'ffmpeg*'
EOF
}

if test "$1" = audit; then
    shift

    check=1
    download=1

    while getopts hdc f; do
	case "$f" in
	    '?')
		exit 1;;
	    h)
		usage_audit
		exit 0;;
	    d)
		check=;;
	    c)
		download=;;
	esac
    done
    shift `expr $OPTIND - 1`

    if test -n "$download"; then
	verbose 'Downloading new pkg-vulnerabilities file'
	$PKG_ADMIN_CMD fetch-pkg-vulnerabilities -u
    fi
    if test -n "$check"; then
	verbose 'Checking packages for vulnerabilities'
	$PKG_ADMIN_CMD audit "$@"
    fi

    exit 0
fi

######################################################################
######################################################################
######################################################################
# history
usage_history (){
    cat <<'EOF'
nih history [options] [pkgs...]

      Output installed, removed or updated packages last nih sessions
      using saved ~/.nih/installed_*.txt files.

   options:
      -h    display this help message
      -B    consider packages different if their BUILD_DATE differ

Examples:
   nih history -h
   nih history
   nih history -B
EOF
}

if test "$1" = history; then
    shift

    while getopts hB f; do
	case "$f" in
	    '?')
		exit 1;;
	    h)
		usage_history
		exit 0;;
	    B)
		cmp_summary_opts=-b;;
	esac
    done
    shift `expr $OPTIND - 1`

    if test -n "$NO_INSTALLED_COPY"; then
	echo "Warning: NO_INSTALLED_COPY is set in config file!"
    fi

    installed_fn="$tmp_dir/install"
    pkg_bin_summary -f PKGNAME,PKGPATH,automatic,try_out,nih_hold,BUILD_DATE > "$installed_fn"

    last_fn="$installed_fn"
    last=current

    unpacked1_fn="$tmp_dir/unpacked1.txt"
    unpacked2_fn="$tmp_dir/unpacked2.txt"

    ls -r ~/.nih/installed_* |
    while read curr_fn; do
	curr=`echo $curr_fn | awk 'match($0, /[0-9].*[0-9]/) {
	    print substr($0, RSTART, 4) "-" substr($0, RSTART+4, 2) "-" substr($0, RSTART+6, 2) " " substr($0, RSTART+9, 2) ":" substr($0, RSTART+11, 2)}'`
	verbose "$curr vs. $last"

	if echo "$curr_fn" | grep [.]bz2 > /dev/null; then
	    if test "$last_fn" = "$unpacked2_fn"; then
		tmp_fn="$unpacked1_fn"
	    else
		tmp_fn="$unpacked2_fn"
	    fi
	    bzip2 -dc "$curr_fn" > "$tmp_fn"
	    curr_fn="$tmp_fn"
	fi

	pkg_cmp_summary -EA automatic,try_out $cmp_summary_opts -p \
	    "$curr_fn" "$last_fn" |
	awk '$1 != "="' | @libexecdir@/nih/cmp2hr

	last="$curr"
	last_fn="$curr_fn"
    done

    exit 0
fi

######################################################################
######################################################################
######################################################################
# <bad> command
echo "Unknown command '$1', see nih -h for more information" 1>&2
exit 2
