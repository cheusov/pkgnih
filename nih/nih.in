#!/bin/sh

# Copyright (c) 2010, Aleksey Cheusov <vle@gmx.net>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials provided
#       with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

set -e 

export LC_ALL=C

usage (){
    cat 1>&2 <<'EOF'
Usage: pkgnih [global options] command [command options] [command args]

Global options:
 nih -h              - Display help message
 nih -V              - Display nih version
 nih -y              - Answer 'Yes' to all questions

Commands:
 nih <command> -h    - Display help message for a <command>
 nih help            - Display help message
 nih refresh         - Download pkg_summary and SHA512 files
 nih install
 nih upgrade         - Install or upgrade packages
 nih uninstall
 nih delete
 nih remove          - Uninstall packages
 nih verify          - Verify packages integrity
 nih status          - Show the status of installed packages
 nih audit           - Security audit
 nih leaf            - Output or remove leaf packages
 nih license         - Working with licenses
 nih list            - List packages
 nih clean           - Clean-up DESTDIR or packages cache directories
EOF
}

sysconfdir=${NIH_SYSCONFDIR-@sysconfdir@}/nih
libexecdir=${NIH_LIBEXECDIR-@libexecdir@}
confdir=$HOME/.nih

PKG_INFO_CMD=${PKG_INFO_CMD-@PKG_INFO_CMD@}
PKG_ADMIN_CMD=${PKG_ADMIN_CMD-@PKG_ADMIN_CMD@}
PKG_DELETE_CMD=${PKG_DELETE_CMD-@PKG_DELETE_CMD@}

# loading config files
if test -r "$sysconfdir/config"; then
    conffile="$sysconfdir/config"
elif test -r "$confdir/config"; then
    conffile="$confdir/config"
else
    cat <<EOF
Neither $sysconfdir/config nor $confdir/config are readable.
Sorry, I cannot help.
EOF
    exit 1
fi

. "$conffile"

# temp directory
tmp_dir=`mktemp -d /tmp/nih.XXXXXX`
trap "rm -rf $tmp_dir" 0 1 2 15
test -n "$tmp_dir" || exit 1

# handling global options
process_options (){
    alt_getopt \
	h     'usage; exit 0' \
	V     'echo nih-@VERSION@; exit 0' \
	y     'always_yes=1' \
	-- "$@"
}
cmds=`process_options "$@"`
eval "$cmds"

if test $# -eq 0; then
    usage
    exit 1
fi


######################################################################
# functions
format (){
    # $1 - indentation (a number of spaces)
    # $2 - max line size
    spcs="$1"
    shift
    maxsz="$1"
    shift

    runawk -v spcs="$spcs" -v maxsz="$maxsz" -e '
BEGIN {
   pad = ""
   for (i=1; i < spcs; ++i){ # spcs-1 spaces
      pad = pad " "
   }
   nl=1
}

{
   for (i=1; i <= NF; ++i){
      if (nl){
         printf "%s", pad
         nl = 0
         rest = maxsz
      }
      printf " %s", $i
      rest = rest - length($i) - 1
      if (rest < 0){
         nl = 1
         printf "\n"
      }
   }
}

END {
   if (!nl)
      printf "\n"
}
' "$@"
}

show_summary (){
    awk '/^PKGNAME=/ {pkgname=substr($0, 9)}
         /^PKGPATH=/ {pkgpath=substr($0, 9)}
         /^COMMENT=/ {comment=substr($0, 9)}
         NF == 0 {printf "%-20s %s\n", pkgpath, comment}' "$@" |
    sort |
    show_packages
}

show_packages (){
    # $@ - filenames, pkg_info -I format
#    cat "$@"
    awk '{print "    " $0}' "$@"
#    awk '{print $1}' "$@" | format 4 60
}

yesno (){
    # $1 - question
    while true; do
	printf '%s (y/N)? ' "$1"
	if test -n "$always_yes"; then
	    echo Yes
	    return 0
	fi

	read answer
	answer=${answer:-no}
	case "$answer" in
	    y|Y|yes|Yes|YES)
		return 0;;
	    n|N|no|No|NO)
		return 1;;
	esac
    done
}

######################################################################
# help
if test "$1" = help; then
    usage
    exit 0
fi

######################################################################
# refresh
usage_refresh (){
    cat <<'EOF'
nih refresh [options]
     Download pkg_summary.bz2 and SHA512.bz2, save them to ~/.nih/, and
     then unpack them to .txt files.

   options:
      -h     display this help message

~/.nih/config:
   PKG_SUMMARY_URL - URL or file name for pkg_summary.bz2/pkg_summary.txt
   PKG_SUMMARY     - path to pkg_summary.txt, set this variable if you use
                   local pkg_summary, otherwise keep it unset
   fetch function  - download command
EOF
}

if test "$1" = refresh; then
    if test -n "$PKG_SUMMARY"; then
	cat 1>&2 <<EOF
Variable PKG_SUMMARY is set in configuration file.
Nothing to do.
EOF
	exit 1
    fi

    shift
    while getopts h f; do
	case "$f" in
	    '?')
		echo "Unknown suboption $f for command 'refresh'"
		exit 1;;
	    h)
		usage_refresh
		exit 0;;
	esac
    done
    shift `expr $OPTIND - 1`

    cd "$confdir"

    fetch=""
    echo 'Downloading pkg_summary.bz2...'
    mv pkg_summary.bz2 pkg_summary.bz2.old
    fetch "$PKG_SUMMARY_URL/All/pkg_summary.bz2"
    echo done

    echo 'Downloading SHA512.bz2...'
    mv SHA512.bz2 SHA512.bz2.old
    fetch "$PKG_SUMMARY_URL/SHA512.bz2"
    echo done

    bzip2 -dc pkg_summary.bz2 > pkg_summary.txt.tmp
    mv pkg_summary.txt.tmp pkg_summary.txt

    bzip2 -dc SHA512.bz2 > SHA512.txt.tmp
    mv SHA512.txt.tmp SHA512.txt

    exit 0
fi

######################################################################
# ensure that pkg_summary.txt exists
if test -z "$PKG_SUMMARY"; then
    PKG_SUMMARY=$confdir/pkg_summary.txt
fi

if ! test -r "$PKG_SUMMARY"; then
    cat 1>&2 <<EOF
'$PKG_SUMMARY' file doesn't exist or is not readable.
Perhaps you need to run 'nih refresh'
EOF
    exit 1
fi

######################################################################
# install | upgrade
usage_install (){
    cat <<'EOF'
nih install|upgrade <PKGBASEs or PKGPATHs>
      Install or upgrade specified packages.
   options:
      -h     display this help message
      -n     don't actually install a package, just report the steps that
             would be taken if it were.
EOF
}

if test "_$1" = _install -o "_$1" = _upgrade; then
    cmd="$1"
    shift
    while getopts hn f; do
	case "$f" in
	    '?')
		echo "Unknown suboption $f for command 'install'"
		exit 1;;
	    n)
		pkg_opts='-n';;
	    h)
		usage_install
		exit 0;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    plan_summary="$tmp_dir/plan_summary"

    installed_summary="$tmp_dir/installed_summary"
    pkg_bin_summary -fPKGNAME,PKGPATH,COMMENT,automatic > "$installed_summary"

    if test $# -gt 0; then
	for p in "$@"; do
	    if echo "$p" | grep / > /dev/null; then
		field=PKGPATHe
	    else
		field=PKGBASE
	    fi
	    if ! pkg_grep_summary -fPKGNAME,PKGPATH,COMMENT \
		-r -s "$field" "$p" < "$PKG_SUMMARY" >> "$plan_summary"
	    then
		echo "Package '$p' not found" 1>&2
		exit 1
	    fi
	done
    else
	pkg_grep_summary -e automatic \
	    < "$installed_summary" > "$plan_summary"
    fi

    cat "$cmp_pkgs"

    exit 0
fi

######################################################################
# uninstall | remove | delete
usage_uninstall (){
    cat <<'EOF'
nih uninstall|delete|remove <PKGBASEs>
      Remove specified packages, dependent packages and automatically installed
      leaf packages.
   options:
      -h     display this help message
      -n     don't actually deinstall a package, just report the steps that
             would be taken if it were.
EOF
}

if test "_$1" = _uninstall -o "_$1" = _remove -o "_$1" = _delete; then
    shift
    while getopts hn f; do
	case "$f" in
	    '?')
		echo "Unknown suboption $f for command 'uninstall'"
		exit 1;;
	    n)
		pkg_delete_opts='-n';;
	    h)
		usage_uninstall
		exit 0;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    if test $# -eq 0; then
	echo 'Nothing to do' 1>&2
	exit 1
    fi
    pkg_info -I "$@" > "$tmp_dir/1" || true
    if ! test -s "$tmp_dir/1"; then
	echo 'Nothing to do' 1>&2
	exit 1
    fi
    awk '{print $1}' "$tmp_dir/1" > "$tmp_dir/2"

    echo 'The following packages will be removed:'
    show_packages "$tmp_dir/1"

    echo 'The following dependent packages will be removed:'
    pkg_bin_summary -f 'PKGNAME PKGPATH DEPENDS COMMENT' |
    tee "$tmp_dir/installed_summary" | pkg_summary2deps -nrd |
	pkg_subgraph_deps -xnf "$tmp_dir/2" > "$tmp_dir/4"
    pkg_grep_summary -S PKGNAME "$tmp_dir/4" < "$tmp_dir/installed_summary" |
    awk '/^PKGNAME=/ {pkgname=substr($0, 9)}
         /^COMMENT=/ {comment=substr($0, 9)}
         NF == 0 {printf "%-19s %s\n", pkgname, comment}' > "$tmp_dir/3"
    show_packages "$tmp_dir/3"

    if ! yesno 'Remove them'; then
	exit 0
    fi

    cat "$tmp_dir/4" "$tmp_dir/2" | xargs $PKG_DELETE_CMD $pkg_delete_opts

    cat <<'EOF'
The following packages were installed as dependencies
and are no longer needed:
EOF
    pkg_status -l | tee "$tmp_dir/1" | show_packages -
    if ! yesno 'Remove them'; then
	exit 0
    fi
    if yesno 'Recursively'; then
	pkg_delete_opts="$pkg_delete_opts -A"
    fi
    awk '{print $1}' "$tmp_dir/1" | xargs $PKG_DELETE_CMD $pkg_delete_opts

    exit 0
fi

######################################################################
# verify
usage_verify (){
    cat <<'EOF'
nih verify [options] [PKGBASEs]
      Verify installed or listed packages.
      By default all installed packages are verified.
   options:
       -h   display this help message
       -m   check checksums of installed files
       -U   check for REQUIRES/PROVIDES coherence
       -L   check for existence of library files listed in REQUIRES
       -d   check for presence of dependencies
EOF
}

if test "$1" = verify; then
    shift
    opts='k'
    while getopts hmULdD f; do
	case "$f" in
	    '?')
		echo "Unknown suboption $f for command 'verify'"
		exit 1;;
	    h)
		usage_verify
		exit 0;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    if test k = "$opts"; then
	echo 'Nothing to do' 1>&2
	exit 1
    fi

    export PKG_SUMMARY
    pkg_status "-$opts" "$@"

    exit 0
fi

######################################################################
# status
usage_status (){
    cat <<'EOF'
nih status [options] [PKGBASEs]
      Compare installed packages with pkg_summary.txt (default) or
      pkgsrc tree.

   options:
      -h     display this help message
      -b     compare installed packages against pkg_summary.txt (default)
      -s     compare installed packages against pkgsrc tree
      -r     raw output (pkg_summary format)
      -u     analyse packages marked as installed by user (the default, see -a)
      -a     analyse all packages (see -u)
      -q     no noisy reminder about output format
EOF
}

if test "$1" = status; then
    shift
    opts='b'
    while getopts hbsruaQ f; do
	case "$f" in
	    '?')
		echo "Unknown suboption $f for command 'status'"
		exit 1;;
	    h)
		usage_status
		exit 0;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    export PKG_SUMMARY
    pkg_status "-$opts" "$@"

    exit 0
fi

######################################################################
# audit
if test "$1" = audit; then
    exit 0
fi

######################################################################
# search
usage_search (){
    cat <<'EOF'
nih search [options] [arguments]
      Search for packages

   option:
      -h    display this help message
      -b    search pkg_summary.txt (the default)
      -o    search using pkg_online
      -s    output search strategies
      -f    output search fields
      -<X>  all other options are passed directly to
            pkg_digger(1), see 'pkg_digger -h'
EOF
}

if test "$1" = search; then
    shift
    export PKG_DIGGER_SUMMARY="$PKG_SUMMARY"

    while getopts hbosf139irq f; do
	case "$f" in
	    '?')
		echo "Unknown suboption $f for command 'leaf'"
		exit 1;;
	    b)
		unset PKG_DIGGER_BACKEND || true;;
	    o)
		export PKG_DIGGER_BACKEND=pkg_online_client;;
	    h)
		usage_search
		exit 0;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    pkg_digger ${opts+-$opts} "$@"

    exit 0
fi

######################################################################
# leaf
usage_leaf (){
    cat <<'EOF'
nih leaf [options]
      Output or remove automatically installed leaf packages,
      by default list of packages is output.

   option:
      -h    display this help message
      -t    output only PKGNAME
      -R    remove automatically installed leaf packages
      -E    the same as -R but with 'pkg_delete -A'
      -n    pass -n to pkg_delete
EOF
}

if test "$1" = leaf; then
    shift
    opts='l'
    while getopts htREn f; do
	case "$f" in
	    '?')
		echo "Unknown suboption $f for command 'leaf'"
		exit 1;;
	    h)
		usage_leaf
		exit 0;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    pkg_status "-$opts" "$@"

    exit 0
fi

######################################################################
# list
if test "$1" = list; then
    exit 0
fi

######################################################################
# license
if test "$1" = license; then
    exit 0
fi

######################################################################
# <bad> command
echo "Unknown command '$1', see nih -h for more information" 1>&2
exit 2
