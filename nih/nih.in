#!/bin/sh

# Copyright (c) 2010, Aleksey Cheusov <vle@gmx.net>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials provided
#       with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

set -e 

export LC_ALL=C

usage (){
    cat 1>&2 <<'EOF'
Usage: pkgnih [global options] command [command options] [command args]

Global options:
 nih -h              - Display help message
 nih -V              - Display nih version
 nih -y              - Answer 'Yes' to all questions

Commands:
 nih <command> -h    - Display help message for a <command>
 nih help            - Display help message
 nih refresh         - Download pkg_summary and SHA512 files
 nih install
 nih upgrade         - Install or upgrade packages
 nih uninstall
 nih delete
 nih remove          - Uninstall packages
 nih verify          - Verify packages integrity
 nih status          - Show the status of installed packages
 nih audit           - Security audit
 nih leaf            - Output or remove leaf packages
 nih license         - Working with licenses
 nih list            - List packages
 nih mark            - Mark packages
 nih deps            - Show dependencies
 nih clean           - Clean-up DESTDIR or packages cache directories
EOF
}

sysconfdir=${NIH_SYSCONFDIR-@sysconfdir@}/nih
libexecdir=${NIH_LIBEXECDIR-@libexecdir@}
confdir=$HOME/.nih

PACKAGES=${PACKAGES-@PACKAGES@}
PKG_INFO_CMD=${PKG_INFO_CMD-@PKG_INFO_CMD@}
PKG_ADMIN_CMD=${PKG_ADMIN_CMD-@PKG_ADMIN_CMD@}
PKG_DELETE_CMD=${PKG_DELETE_CMD-@PKG_DELETE_CMD@}
PKG_UPDATE_PLAN_CMD=${PKG_UPDATE_PLAN_CMD-$libexecdir/pkg_update_plan}

# loading config files
if test -r "$sysconfdir/config"; then
    conffile="$sysconfdir/config"
elif test -r "$confdir/config"; then
    conffile="$confdir/config"
else
    cat <<EOF
Neither $sysconfdir/config nor $confdir/config are readable.
Sorry, I cannot help.
EOF
    exit 1
fi

. "$conffile"

# temp directory
tmp_dir=`mktemp -d /tmp/nih.XXXXXX`
trap "rm -rf $tmp_dir" 0 1 2 15
test -n "$tmp_dir" || exit 1

# handling global options
process_options (){
    alt_getopt \
	h     'usage; exit 0' \
	V     'echo nih-@VERSION@; exit 0' \
	y     'always_yes=1' \
	-- "$@"
}
cmds=`process_options "$@"`
eval "$cmds"

if test $# -eq 0; then
    usage
    exit 1
fi


######################################################################
# functions
format (){
    # $1 - indentation (a number of spaces)
    # $2 - max line size
    spcs="$1"
    shift
    maxsz="$1"
    shift

    runawk -v spcs="$spcs" -v maxsz="$maxsz" -e '
BEGIN {
   pad = ""
   for (i=1; i < spcs; ++i){ # spcs-1 spaces
      pad = pad " "
   }
   nl=1
}

{
   for (i=1; i <= NF; ++i){
      if (nl){
         printf "%s", pad
         nl = 0
         rest = maxsz
      }
      printf " %s", $i
      rest = rest - length($i) - 1
      if (rest < 0){
         nl = 1
         printf "\n"
      }
   }
}

END {
   if (!nl)
      printf "\n"
}
' "$@"
}

show_summary (){
    awk '/^PKGNAME=/ {pkgname=substr($0, 9)}
         /^PKGPATH=/ {pkgpath=substr($0, 9)}
         /^COMMENT=/ {comment=substr($0, 9)}
         NF == 0 {printf "%s\t%s\t%s\n", pkgpath, pkgname, comment}' "$@" |
    sort |
    show_packages
}

indent (){
    awk '{print "    " $0}' "$@"
}

show_packages (){
    awk -F'\t' '{printf "%s (%s)\n     %s\n", $1, $2, $3}' "$@" | indent
}

cleanup_db (){
    echo 'Update PKGDB' 1>&2
    $PKG_ADMIN_CMD rebuild-tree
}

yesno (){
    # $1 - question
    while true; do
	printf '%s (y/N)? ' "$1"
	if test -n "$always_yes"; then
	    echo Yes
	    return 0
	fi

	read answer
	answer=${answer:-no}
	case "$answer" in
	    y|Y|yes|Yes|YES)
		return 0;;
	    n|N|no|No|NO)
		return 1;;
	esac
    done
}

verbose (){
    printf "%s\n" "$1"
}

######################################################################
# help
if test "$1" = help; then
    usage
    exit 0
fi

######################################################################
# refresh
usage_refresh (){
    cat <<'EOF'
nih refresh [options]
     Download pkg_summary.bz2 and SHA512.bz2, save them to ~/.nih/, and
     then unpack them to .txt files.

   options:
      -h     display this help message

~/.nih/config:
   PKG_SUMMARY_URL - URL or file name for pkg_summary.bz2/pkg_summary.txt
   PKG_SUMMARY     - path to pkg_summary.txt, set this variable if you use
                   local pkg_summary, otherwise keep it unset
   fetch function  - download command
EOF
}

if test "$1" = refresh; then
    if test -n "$PKG_SUMMARY"; then
	cat 1>&2 <<EOF
Variable PKG_SUMMARY is set in configuration file.
Nothing to do.
EOF
	exit 1
    fi

    shift
    while getopts h f; do
	case "$f" in
	    '?')
		echo "Unknown suboption $f for command 'refresh'"
		exit 1;;
	    h)
		usage_refresh
		exit 0;;
	esac
    done
    shift `expr $OPTIND - 1`

    cd "$confdir"

    fetch=""
    echo 'Downloading pkg_summary.bz2...'
    mv pkg_summary.bz2 pkg_summary.bz2.old
    fetch "$PKG_SUMMARY_URL/All/pkg_summary.bz2"
    echo done

    echo 'Downloading SHA512.bz2...'
    mv SHA512.bz2 SHA512.bz2.old
    fetch "$PKG_SUMMARY_URL/SHA512.bz2"
    echo done

    bzip2 -dc pkg_summary.bz2 > pkg_summary.txt.tmp
    mv pkg_summary.txt.tmp pkg_summary.txt

    bzip2 -dc SHA512.bz2 > SHA512.txt.tmp
    mv SHA512.txt.tmp SHA512.txt

    exit 0
fi

######################################################################
# ensure that pkg_summary.txt exists
if test -z "$PKG_SUMMARY"; then
    PKG_SUMMARY=$confdir/pkg_summary.txt
fi

if ! test -r "$PKG_SUMMARY"; then
    cat 1>&2 <<EOF
'$PKG_SUMMARY' file doesn't exist or is not readable.
Perhaps you need to run 'nih refresh'
EOF
    exit 1
fi

######################################################################
# install | upgrade
usage_install (){
    cat <<'EOF'
nih install|upgrade <PKGBASEs or PKGPATHs>
      Install or upgrade specified packages.
   options:
      -h     display this help message
      -n     don't actually install a package, just report the steps that
             would be taken if it were.
EOF
}

download_pkgs (){
    (
	cd "$PACKAGES/All"
	while read pkg; do
	    if ! test -f "$pkg.tgz"; then
		echo "Downloading package $pkg..."
		fetch "$PKG_SUMMARY_URL/All/$pkg.tgz"
	    fi
	done
    )
}

grep_line (){
    # $1 - line
    # $2.. - files
    line="$1"
    shift
    awk -v line="$line" '$0 == line {print $0; exit 0} END {exit 1}' "$@"
}

if test "_$1" = _install -o "_$1" = _upgrade; then
    cmd="$1"
    shift
    while getopts hn f; do
	case "$f" in
	    '?')
		echo "Unknown suboption $f for command 'install'"
		exit 1;;
	    n)
		pkg_opts='-n';;
	    h)
		usage_install
		exit 0;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    verbose "Getting installed packages..."
    installed_summary="$tmp_dir/installed_summary"
    pkg_bin_summary -fPKGNAME,PKGPATH,COMMENT,automatic,CONFLICTS,DEPENDS \
	> "$installed_summary"

    if test $# -eq 0; then
	echo 'Not implemented yet' 1>&2
	exit 1
    fi

    verbose "Generating the update plan..."
    plan_summary="$tmp_dir/plan_summary"
    cmp_summary="$tmp_dir/cmp_summary"
    if $PKG_UPDATE_PLAN_CMD -v "$installed_summary" "$PKG_SUMMARY" \
	"$@" > "$plan_summary"
    then
	:
    else
#	echo 'Something goes wrong' 1>&2
	cat "$plan_summary" 1>&2
	exit 1
    fi
#    verbose "Getting installed packages..."

    pkg_cmp_summary "$installed_summary" "$plan_summary" |
    grep -v '^=' > "$cmp_summary" || true

    # note about our upgrade plan
    printf '%s\n' '---------------------- UPDATE PLAN -------------------------'

    rem_pkgs=`awk '$1 == "-" {print $2}' "$cmp_summary"`
    rem_pkgs=`echo $rem_pkgs` # remove NL characters
    rem_summary="$tmp_dir/rem_summary"
    pkg_grep_summary -t strlist PKGBASE "$rem_pkgs" \
	< "$installed_summary" > "$rem_summary"

    inst_pkgs=`awk '$1 ~ /^[+<>]$/ {print $2}' "$cmp_summary"`
    inst_pkgs=`echo $inst_pkgs`

    auto_pkgs=`pkg_grep_summary -v -e automatic < "$plan_summary" |
	sed -n 's/^PKGNAME=//p'`
    auto_pkgs=`echo $auto_pkgs`

    inst_auto_summary="$tmp_dir/inst_auto_summary"
    pkg_grep_summary -t strlist PKGBASE "$inst_pkgs" < "$plan_summary" |
    pkg_grep_summary -t strlist PKGNAME "$auto_pkgs" > "$inst_auto_summary"

    inst_summary="$tmp_dir/inst_summary"
    pkg_grep_summary -t strlist PKGBASE "$inst_pkgs" < "$plan_summary" |
    pkg_grep_summary -v -t strlist PKGNAME "$auto_pkgs" > "$inst_summary"

    conflicts_msg="$tmp_dir/conflicts"
    if ! pkg_lint_summary -c "$inst_summary" "$inst_auto_summary" \
	"$installed_summary" > "$conflicts_msg"
    then
	extra_rem_pkgs="$tmp_dir/extra_rem"
	extra_rem_summary="$tmp_dir/extra_rem_summary"
	awk '$1 == "c:" {print $5; print $8}' "$conflicts_msg" |
	sort -u > "$extra_rem_pkgs"
	pkg_grep_summary -t strfile PKGNAME "$extra_rem_pkgs" \
	    < "$installed_summary" > "$extra_rem_summary"
    fi

    echo 'The following packages will be removed'
    show_summary "$rem_summary"
    if test -s "$extra_rem_summary"; then
	echo '    //'
	show_summary "$extra_rem_summary"
    fi
    echo 'The following packages will be installed'
    show_summary "$inst_summary"
    echo 'The following packages will be installed as dependencies'
    show_summary "$inst_auto_summary"

    if ! yesno 'Proceed'; then
	exit 0
    fi

    ######################## installing ###########################
    sed -n 's/^PKGNAME=//p' "$inst_summary" "$inst_auto_summary" |
    download_pkgs

    if test -s "$rem_summary" -o -s "$extra_rem_summary"; then
	sed -n 's/^PKGNAME=//p' "$rem_summary" "$extra_rem_summary" |
	while read pkg; do
	    echo "Removing package $pkg..." 1>&2
	    $PKG_DELETE_CMD -f $pkg_opts "$pkg"
	done
    fi

    pkg_summary2deps -ndtr "$plan_summary" | tsort |
    while read pkg; do
	if pkg_grep_summary -r -s PKGNAME "$pkg" < "$inst_auto_summary" > /dev/null; then
	    echo "Installing package $pkg as a dependency..." 1>&2
	    if ! pkg_add $pkg_opts -UA "$PACKAGES/All/$pkg.tgz"; then
		cleanup_db; exit 1
	    fi
	elif pkg_grep_summary -r -s PKGNAME "$pkg" < "$inst_summary" > /dev/null; then
	    echo "Installing package $pkg..." 1>&2
	    if ! pkg_add $pkg_opts -U "$PACKAGES/All/$pkg.tgz"; then
		cleanup_db; exit 1
	    fi
	fi
    done
    cleanup_db
    exit 0
fi

######################################################################
# uninstall | remove | delete
usage_uninstall (){
    cat <<'EOF'
nih uninstall|delete|remove <PKGBASEs>
      Remove specified packages, dependent packages and automatically installed
      leaf packages.
   options:
      -h     display this help message
      -n     don't actually deinstall a package, just report the steps that
             would be taken if it were.
EOF
}

if test "_$1" = _uninstall -o "_$1" = _remove -o "_$1" = _delete; then
    shift
    while getopts hn f; do
	case "$f" in
	    '?')
		echo "Unknown suboption $f for command 'uninstall'"
		exit 1;;
	    n)
		pkg_delete_opts='-n';;
	    h)
		usage_uninstall
		exit 0;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    if test $# -eq 0; then
	echo 'Nothing to do' 1>&2
	exit 1
    fi
    pkg_info -I "$@" > "$tmp_dir/1" || true
    if ! test -s "$tmp_dir/1"; then
	echo 'Nothing to do' 1>&2
	exit 1
    fi
    awk '{print $1}' "$tmp_dir/1" > "$tmp_dir/2"

    echo 'The following packages will be removed:'
    indent "$tmp_dir/1"

    echo 'The following dependent packages will be removed:'
    pkg_bin_summary -f 'PKGNAME PKGPATH DEPENDS COMMENT' |
    tee "$tmp_dir/installed_summary" | pkg_summary2deps -nrd |
	pkg_subgraph_deps -xnf "$tmp_dir/2" > "$tmp_dir/4"
    pkg_grep_summary -S PKGNAME "$tmp_dir/4" < "$tmp_dir/installed_summary" |
    awk '/^PKGNAME=/ {pkgname=substr($0, 9)}
         /^COMMENT=/ {comment=substr($0, 9)}
         NF == 0 {printf "%-19s %s\n", pkgname, comment}' > "$tmp_dir/3"
    indent "$tmp_dir/3"

    if ! yesno 'Remove them'; then
	exit 0
    fi

    cat "$tmp_dir/4" "$tmp_dir/2" | xargs $PKG_DELETE_CMD $pkg_delete_opts

    cat <<'EOF'
The following packages were installed as dependencies
and are no longer needed:
EOF
    pkg_status -l | tee "$tmp_dir/1" | indent -
    if ! yesno 'Remove them'; then
	exit 0
    fi
    if yesno 'Recursively'; then
	pkg_delete_opts="$pkg_delete_opts -A"
    fi
    awk '{print $1}' "$tmp_dir/1" | xargs $PKG_DELETE_CMD $pkg_delete_opts

    exit 0
fi

######################################################################
# verify
usage_verify (){
    cat <<'EOF'
nih verify [options] [PKGBASEs]
      Verify installed or listed packages.
      By default all installed packages are verified.
   options:
       -h   display this help message
       -m   check checksums of installed files
       -U   check for REQUIRES/PROVIDES coherence
       -L   check for existence of library files listed in REQUIRES
       -d   check for presence of dependencies
EOF
}

if test "$1" = verify; then
    shift
    opts='k'
    while getopts hmULdD f; do
	case "$f" in
	    '?')
		echo "Unknown suboption $f for command 'verify'"
		exit 1;;
	    h)
		usage_verify
		exit 0;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    if test k = "$opts"; then
	echo 'Nothing to do' 1>&2
	exit 1
    fi

    export PKG_SUMMARY
    pkg_status "-$opts" "$@"

    exit 0
fi

######################################################################
# status
usage_status (){
    cat <<'EOF'
nih status [options] [PKGBASEs]
      Compare installed packages with pkg_summary.txt (default) or
      pkgsrc tree.

   options:
      -h     display this help message
      -b     compare installed packages against pkg_summary.txt (default)
      -s     compare installed packages against pkgsrc tree
      -r     raw output (pkg_summary format)
      -u     analyse packages marked as installed by user (the default, see -a)
      -a     analyse all packages (see -u)
      -q     no noisy reminder about output format
EOF
}

if test "$1" = status; then
    shift
    opts='b'
    while getopts hbsruaQ f; do
	case "$f" in
	    '?')
		echo "Unknown suboption $f for command 'status'"
		exit 1;;
	    h)
		usage_status
		exit 0;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    export PKG_SUMMARY
    pkg_status "-$opts" "$@"

    exit 0
fi

######################################################################
# audit
if test "$1" = audit; then
    exit 0
fi

######################################################################
# search
usage_search (){
    cat <<'EOF'
nih search [options] [arguments]
      Search for packages

   option:
      -h    display this help message
      -b    search in pkg_summary.txt (the default)
      -o    search using pkg_online
      -I    search in installed packages
      -s    output search strategies
      -f    output search fields
      -<X>  all other options are passed directly to
            pkg_digger(1), see 'pkg_digger -h'
EOF
}

if test "$1" = search; then
    shift
    export PKG_DIGGER_SUMMARY="$PKG_SUMMARY"

    while getopts hboIsf139irq f; do
	case "$f" in
	    '?')
		echo "Unknown suboption $f for command 'leaf'"
		exit 1;;
	    b)
		unset PKG_DIGGER_BACKEND || true
		unset in_installed || true;;
	    o)
		export PKG_DIGGER_BACKEND=pkg_online_client
		unset in_installed || true;;
	    I)
		unset PKG_DIGGER_BACKEND || true
		in_installed=1;;
	    h)
		usage_search
		exit 0;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    if test -n "$in_installed"; then
	export PKG_DIGGER_SUMMARY="$tmp_dir/installed_summary"
	pkg_bin_summary -a automatic > "$PKG_DIGGER_SUMMARY"
    fi

    pkg_digger ${opts+-$opts} "$@"

    exit 0
fi

######################################################################
# leaf
usage_leaf (){
    cat <<'EOF'
nih leaf [options]
      Output or remove automatically installed leaf packages,
      by default list of packages is output.

   option:
      -h    display this help message
      -t    output only PKGNAME
      -R    remove automatically installed leaf packages
      -E    the same as -R but with 'pkg_delete -A'
      -n    pass -n to pkg_delete
EOF
}

if test "$1" = leaf; then
    shift
    opts='l'
    while getopts htREn f; do
	case "$f" in
	    '?')
		echo "Unknown suboption $f for command 'leaf'"
		exit 1;;
	    h)
		usage_leaf
		exit 0;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    pkg_status "-$opts" "$@"

    exit 0
fi

######################################################################
# list
if test "$1" = list; then
    exit 0
fi

######################################################################
# mark
usage_mark (){
    cat <<'EOF'
nih mark [options] PKGBASEs
      Mark packages

   option:
      -h    display this help message
      -u    mark packages as installed by user
      -d    mark packages as dependencies
EOF
}

if test "$1" = mark; then
    shift
    opts='l'
    while getopts hud f; do
	case "$f" in
	    '?')
		echo "Unknown suboption $f for command 'mark'"
		exit 1;;
	    h)
		usage_mark
		exit 0;;
	    u)
		mode_u=1;;
	    d)
		mode_d=1;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    if test "$mode_u$mode_d" = 11; then
	echo '-u and -d options are exclusive' 1>&2
	exit 1
    elif test -z "$mode_u$mode_d"; then
	echo 'Either -u or -d must be applied' 1>&2
	exit 1
    elif test -n "$mode_d"; then
	cmd='set automatic=yes'
    else
	cmd='unset automatic'
    fi

    if test $# -eq 0; then
	echo 'No packages were specified' 1>&2
	exit 
    fi

    $PKG_ADMIN_CMD $cmd "$@"
    exit 0
fi

######################################################################
# deps
usage_deps (){
    cat <<'EOF'
nih deps [options] [pkgs...]
      Output a dependency graph of installed packages.

   option:
      -h    display this help message
      -r    output dependencies, by default packages
            that depend on "pkgs" are output.
      -l    output list of packages instead of graph
      -B    output PKGBASE (the default)
      -P    output PKGPATH
      -N    output PKGNAME
EOF
}

if test "$1" = deps; then
    shift
    sb_opts=''
    pn_opts=''
    while getopts hrlBNP f; do
	case "$f" in
	    '?')
		echo "Unknown suboption $f for command 'deps'"
		exit 1;;
	    h)
		usage_deps
		exit 0;;
	    r)
		sb_opts="$sb_opts -r";;
	    l)
		sb_opts="$sb_opts -n";;
	    B)
		pn_opts="$pn_opts -n";;
	    N)
		pn_opts="$pn_opts -nr";;
	    P)
		pn_opts="$pn_opts -p";;
	esac
    done
    shift `expr $OPTIND - 1`

    pn_opts=${pn_opts:--n}

    pkg_bin_summary -fPKGNAME,PKGPATH,DEPENDS |
    pkg_summary2deps -d $pn_opts |
    if test $# -eq 0; then
	sort -u
    else
	pkg_subgraph_deps $sb_opts -p "$*" | sort -u
    fi
    exit 0
fi

######################################################################
# license
if test "$1" = license; then
    exit 0
fi

######################################################################
# <bad> command
echo "Unknown command '$1', see nih -h for more information" 1>&2
exit 2
