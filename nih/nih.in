#!/bin/sh

# Copyright (c) 2010, Aleksey Cheusov <vle@gmx.net>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials provided
#       with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

set -e 

export LC_ALL=C

usage (){
    cat 1>&2 <<'EOF'
Usage:
  pkgnih [global options] command [command options] [--] [command args]

Global options:
 nih -h              - Display help message
 nih -V              - Display nih version
 nih -y              - Answer 'Yes' to all questions

Commands:
 nih <command> -h    - Display help message for a <command>
 nih help            - Display help message
 nih refresh         - Download pkg_summary and SHA512 files
 nih install
   nih update        - Install or update packages
 nih uninstall
   nih delete
   nih remove        - Uninstall packages
 nih verify          - Verify packages integrity
 nih status          - Show the status of installed packages
 nih info            - Show information about package
 nih leaf            - Output or remove leaf packages
 nih license         - Working with licenses
 nih list            - List packages
 nih mark            - Mark packages
 nih deps            - Show dependencies
 nih clean-cache     - Clean-up cache directory with binaries
EOF
}

sysconfdir=${NIH_SYSCONFDIR-@sysconfdir@}/nih
confdir=$HOME/.nih

CACHEDIR=${CACHEDIR-@CACHEDIR@}
PKG_INFO_CMD=${PKG_INFO_CMD-@PKG_INFO_CMD@}
PKG_ADMIN_CMD=${PKG_ADMIN_CMD-@PKG_ADMIN_CMD@}
PKG_DELETE_CMD=${PKG_DELETE_CMD-@PKG_DELETE_CMD@}
PKG_UPDATE_PLAN_CMD=${PKG_UPDATE_PLAN_CMD-pkg_update_plan}
SUFX=${SUFX-.tgz}

# loading config files
if test -r "$sysconfdir/config"; then
    conffile="$sysconfdir/config"
elif test -r "$confdir/config"; then
    conffile="$confdir/config"
else
    cat <<EOF
Neither $sysconfdir/config nor $confdir/config are readable.
Sorry, I cannot help.
EOF
    exit 1
fi

. "$conffile"

# temp directory
tmp_dir=`mktemp -d /tmp/nih.XXXXXX`
trap "rm -rf $tmp_dir" 0 1 2 15
test -n "$tmp_dir" || exit 1

# handling global options
process_options (){
    alt_getopt \
	h     'usage; exit 0' \
	V     'echo nih-@VERSION@; exit 0' \
	y     'always_yes=1' \
	-- "$@"
}
cmds=`process_options "$@"`
eval "$cmds"

if test $# -eq 0; then
    usage
    exit 1
fi


######################################################################
######################################################################
######################################################################
# functions
format (){
    # $1 - indentation (a number of spaces)
    # $2 - max line size
    spcs="$1"
    shift
    maxsz="$1"
    shift

    runawk -v spcs="$spcs" -v maxsz="$maxsz" -e '
BEGIN {
   pad = ""
   for (i=1; i < spcs; ++i){ # spcs-1 spaces
      pad = pad " "
   }
   nl=1
}

{
   for (i=1; i <= NF; ++i){
      if (nl){
         printf "%s", pad
         nl = 0
         rest = maxsz
      }
      printf " %s", $i
      rest = rest - length($i) - 1
      if (rest < 0){
         nl = 1
         printf "\n"
      }
   }
}

END {
   if (!nl)
      printf "\n"
}
' "$@"
}

show_summary (){
    awk '/^PKGNAME=/ {pkgname=substr($0, 9)}
         /^PKGPATH=/ {pkgpath=substr($0, 9)}
         /^COMMENT=/ {comment=substr($0, 9)}
         NF == 0 {printf "%s\t%s\t%s\n", pkgpath, pkgname, comment}' "$@" |
    sort |
    show_packages
}

indent (){
    awk '{print "    " $0}' "$@"
}

show_packages (){
    awk -F'\t' '{printf "%s (%s)\n     %s\n", $1, $2, $3}' "$@" | indent
}

cleanup_db (){
    echo 'Updating pkgdb...' 1>&2
    $PKG_ADMIN_CMD rebuild-tree
}

yesno (){
    # $1 - id
    # $2 - question
    while true; do
	printf '%s (y/N)? ' "$2"
	if test -n "$always_yes" || eval 'test -n "$yes_'"$1\""; then
	    echo Yes
	    return 0
	fi

	read answer
	answer=${answer:-no}
	case "$answer" in
	    y|Y|yes|Yes|YES)
		return 0;;
	    n|N|no|No|NO)
		return 1;;
	esac
    done
}

verbose (){
    printf "%s\n" "$1"
}

get_date (){
    date +%Y%m%d_%H%M
}

summary2binary (){
    awk -v SUFX="$SUFX" '
    /^PKGNAME=/ {pkg1 = substr($0, 9) SUFX}
    /^FILE_NAME=/ {pkg2 = substr($0, 11)}
    NF == 0 {
	if (pkg2) print pkg2
	else print pkg1
	pkg1 = pkg2 = ""
    }' "$@"
}

# saves list of installed packages
save_installed_packages (){
    if test -n "$NO_INSTALLED_COPY"; then
	return
    fi

    installed_fn=$confdir/installed_`get_date`
    counter=''
    while test -f "${installed_fn}$counter.txt"; do
	counter=${counter-0}
	counter=$(($counter+1))
    done

    installed_fn="${installed_fn}$counter.txt"
    pkg_bin_summary -f PKGNAME,PKGPATH,DEPENDS,COMMENT,automatic,nih_try,nih_hold \
	> "$installed_fn"
}

######################################################################
######################################################################
######################################################################
# help
if test "$1" = help; then
    usage
    exit 0
fi

######################################################################
######################################################################
######################################################################
# refresh
usage_refresh (){
    cat <<'EOF'
nih refresh [options]

      Download pkg_summary.bz2 and SHA512.bz2, save them to ~/.nih/, and
      then unpack them to .txt files.

   options:
      -h     display this help message

~/.nih/config:
   PKG_SUMMARY_URL - URL or file name for pkg_summary.bz2/pkg_summary.txt
   PKG_SUMMARY     - path to pkg_summary.txt, set this variable if you use
                   local pkg_summary, otherwise keep it unset
   fetch function  - download command
EOF
}

fetch_summary_file (){
    # $1 - extension
    echo "Downloading pkg_summary.$1..."
    if test -f pkg_summary.$1; then
	mv pkg_summary.$1 pkg_summary.$1.old
    fi
    fetch "$PKG_SUMMARY_URL/All/pkg_summary.$1"
    case "$1" in
	gz)  gzip -dc  pkg_summary.gz  > pkg_summary.txt.tmp || return 1;;
	bz2) bzip2 -dc pkg_summary.bz2 > pkg_summary.txt.tmp || return 1;;
	*)   echo 'Unknown ext'; exit 1;;
    esac
    mv pkg_summary.txt.tmp pkg_summary.txt
}

fetch_sha512_file (){
    # $1 - extension
    echo "Downloading SHA512.$1..."
    if test -f SHA512.$1; then
	mv SHA512.$1 SHA512.$1.old
    fi
    fetch "$PKG_SUMMARY_URL/SHA512.$1"
    echo done

    case "$1" in
	gz)   gzip  -dc SHA512.$1 > SHA512.txt.tmp || return 1;;
	bz2)  bzip2 -dc SHA512.$1 > SHA512.txt.tmp || return 1;;
	*)   echo 'Unknown ext'; exit 1;;
    esac
    mv SHA512.txt.tmp SHA512.txt
}

if test "$1" = refresh; then
    shift
    while getopts h f; do
	case "$f" in
	    '?')
		exit 1;;
	    h)
		usage_refresh
		exit 0;;
	esac
    done
    shift `expr $OPTIND - 1`

    if test -n "$PKG_SUMMARY"; then
	cat 1>&2 <<EOF
Variable PKG_SUMMARY is set in configuration file.
Nothing to do.
EOF
	exit 1
    fi

    cd "$confdir"

    fetch=""

    if ! fetch_summary_file bz2 && ! fetch_summary_file gz; then
	exit 1
    fi

    if ! fetch_sha512_file bz2 && ! fetch_sha512_file gz; then
	exit 1
    fi

    if test -z "$NO_SUMMARY_COPY"; then
	date_sufx=`get_date`
	cp pkg_summary.txt pkg_summary_${date_sufx}.txt
	cp SHA512.txt SHA512_${date_sufx}.txt
    fi
    exit 0
fi

######################################################################
# ensure that pkg_summary.txt exists and refresh it
if test -z "$PKG_SUMMARY"; then
    cksums=1 # checksums will be checked according to SHA512.txt
    PKG_SUMMARY=$confdir/pkg_summary.txt
fi

summary_exists (){
    if ! test -r "$PKG_SUMMARY"; then
	cat 1>&2 <<EOF
'$PKG_SUMMARY' file doesn't exist or is not readable.
Perhaps you need to run 'nih refresh'
EOF
	exit 1
    fi
}

mkdir -p "$confdir"

refresh_summary (){
    summary_exists

    tiny_summary="$tmp_dir/tiny_summary"
    grep -E '^$|^(PKGNAME|PKGPATH|COMMENT|automatic|CONFLICTS|DEPENDS|BUILD_DATE|PROVIDES|REQUIRES|FILE_NAME)=' \
	"$PKG_SUMMARY" > "$tiny_summary" || true
    export PKG_SUMMARY="$tiny_summary"
}

######################################################################
######################################################################
######################################################################
# install | update
usage_install (){
    cat <<'EOF'
nih update  <packages>
nih install <packages>

      Install or update specified packages. These commands are the same.

   options:
      -h     display this help message
      -n     don't actually install a package, just report the steps that
             would be taken if it were.
      -d     download binaries only, do not update installed packages
      -B     consider packages different if their BUILD_DATE differ
      -D     For debugging purposes

Here <packages> are either PKGBASEs, PKGNAMEs or PKGPATHs, optionally
prepended with `+' (package will be marked as installed as a dependency)
or `-' (package will be removed). If neither `+' nor `-' were specified
packages will be marked as installed by user. The marker `-' may be useful
for resolving conflicts between installed and new packages. Automatically
installed leaf packages will be removed.

Examples:
   nih update
   nih update -d
   nih install mawk lang/gawk
   nih install perl
   nih install +GConf +xproto
   nih install -- -gmake -autoconf -automake -libtool-base
   nih install textproc/dict-client -wip/dict-client
EOF
}

check_cksums (){
    # $1 - foobar-1.2.3.tgz
    if test -z "$cksums"; then
	return
    fi

    expected_sha512=`awk -v p="(All/$1)" '$2 == p {print $4}' $confdir/SHA512.txt`
    curr_sha512=`digest sha512 "$1" | awk '{print $4}'`
    if test "$expected_sha512" = "$curr_sha512"; then
	return 0
    else
	echo "$1 is corrupted, checksum mismatch"
	return 1
    fi
}

download_pkgs (){
    (
	cd "$CACHEDIR/All"
	while read pkg; do
	    if ! test -f "$pkg$SUFX" || ! check_cksums "$pkg$SUFX"; then
		echo "Downloading package $pkg..."
		fetch "$PKG_SUMMARY_URL/All/$pkg$SUFX"
		# ensure that downloaded file is correct
		check_cksums "$pkg$SUFX"
	    fi
	done
    )
}

grep_lines (){
    # $1 - file with lines
    awk 'FILENAME != "-" { hash [$0] = 0; next }
	($0 in hash) {print $0 }' "$1" -
}

rev_lines (){
    # $@ - files
    awk '{ line [NR] = $0 }
    END { for (i=NR; i >= 1; --i) print line [i] }' "$@"
}

if test "_$1" = _install -o "_$1" = _update; then
    cmd="$1"
    shift

    while getopts hndBD f; do
	case "$f" in
	    '?')
		exit 1;;
	    n)
		pkg_opts='-n';;
	    h)
		usage_install
		exit 0;;
	    d)
		download_only=1;;
	    B)
		cmp_opts='-b';;
	    D)
		debug=1;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    refresh_summary

    verbose "Getting a list of installed packages..."
    installed_summary="$tmp_dir/installed_summary"
    pkg_bin_summary \
	-fPROVIDES,REQUIRES,PKGNAME,PKGPATH,COMMENT,automatic,CONFLICTS,DEPENDS,BUILD_DATE \
	> "$installed_summary"

    cmp_summary="$tmp_dir/cmp_summary"

    update_pkgs_fn="$tmp_dir/pkgs_specs.txt"
    printf '' > "$update_pkgs_fn"
    if test $# -eq 0; then
	pkg_cmp_summary -p $cmp_opts "$installed_summary" "$PKG_SUMMARY" \
	    > "$cmp_summary"
	awk '$1 ~ /^[<!]/ {
		print "-" $3
		print "?" $3 "-" $5
	}' "$cmp_summary" > "$update_pkgs_fn"
    else
	for i; do
	    if echo "$i" | grep -E '^[+*?]?/' > /dev/null; then
		prefix=`echo "$i" | sed 's|/.*$||'`
		fn=`echo "$i" | sed 's|^[^/]*||'`
		pkg_info -X "$fn" |
		sed "s ^FILE_NAME=.*$ FILE_NAME=$fn " |
		tee "$tiny_summary".tmp |
		awk -v prefix="$prefix" '
		     /^PKGPATH=/ {p=substr($0, 9)}
		     /^PKGNAME=/ {n=substr($0, 9)}
		     END {print prefix p "," n}' >> "$update_pkgs_fn"
		cat "$tiny_summary" >> "$tiny_summary".tmp
		pkg_uniq_summary "$tiny_summary".tmp > "$tiny_summary"
	    else
		printf '%s\n' "$i" >> "$update_pkgs_fn"
	    fi
	done
    fi

    ##################################################################
    ######################### update plan ############################
    verbose "Generating an update plan..."
    plan_summary="$tmp_dir/plan_summary"
    printf '' > "$plan_summary"
    if ! test -s "$update_pkgs_fn"; then
	echo 'Nothing to do'
	exit 0
    fi

    if test -n "$debug"; then
	debug_opt=-v
    fi

    if ! $PKG_UPDATE_PLAN_CMD -iv $debug_opt "$installed_summary" "$PKG_SUMMARY" \
	    > "$plan_summary" < "$update_pkgs_fn"
    then
	cat "$plan_summary" 1>&2
	exit 1
    fi

    pkg_cmp_summary $cmp_opts "$installed_summary" "$plan_summary" |
    grep -v '^=' > "$cmp_summary" || true

    pkg_grep_summary -s force_update yes < "$plan_summary" |
    awk '/^PKGNAME=/ {
	base = ver = substr($0, 9)
	sub(/-[^-]*$/, "", base)
	sub(/^.*-/, "", ver)
	printf "! %s x %s\n", base, ver}' >> "$cmp_summary"

    printf '%s\n' '---------------------- UPDATE PLAN -------------------------'

    rem_pkgs=`awk '$1 == "-" {print $2}' "$cmp_summary"`
    rem_pkgs=`echo $rem_pkgs` # remove NL characters
    rem_summary="$tmp_dir/rem_summary"
    pkg_grep_summary -t strlist PKGBASE "$rem_pkgs" \
	< "$installed_summary" > "$rem_summary"

    inst_pkgs=`awk '$1 ~ /^[+<>!]$/ {print $2}' "$cmp_summary"`
    inst_pkgs=`echo $inst_pkgs`

    auto_pkgs=`pkg_grep_summary -v -e automatic < "$plan_summary" |
	sed -n 's/^PKGNAME=//p'`
    auto_pkgs=`echo $auto_pkgs`

    inst_auto_summary="$tmp_dir/inst_auto_summary"
    pkg_grep_summary -t strlist PKGBASE "$inst_pkgs" < "$plan_summary" |
    pkg_grep_summary -t strlist PKGNAME "$auto_pkgs" > "$inst_auto_summary"

    inst_summary="$tmp_dir/inst_summary"
    pkg_grep_summary -t strlist PKGBASE "$inst_pkgs" < "$plan_summary" |
    pkg_grep_summary -v -t strlist PKGNAME "$auto_pkgs" > "$inst_summary"

    conflicts_msg="$tmp_dir/conflicts"
    extra_rem_pkgs="$tmp_dir/extra_rem"
    extra_rem_summary="$tmp_dir/extra_rem_summary"
    printf '' > "$extra_rem_summary"
    if ! pkg_lint_summary -cd "$inst_summary" "$inst_auto_summary" \
	"$installed_summary" > "$conflicts_msg"
    then
	awk '$1 == "c:" {print $5; print $8}
	     $1 == "d:" {print $6}' "$conflicts_msg" |
	sort -u > "$extra_rem_pkgs"
	pkg_grep_summary -t strfile PKGNAME "$extra_rem_pkgs" \
	    < "$installed_summary" > "$extra_rem_summary"
    fi

    echo 'The following packages will be removed'
    show_summary "$rem_summary"
    if test -s "$extra_rem_summary"; then
	echo '    //'
	show_summary "$extra_rem_summary"
    fi
    echo 'The following packages will be installed'
    show_summary "$inst_summary"
    echo 'The following packages will be installed as auto-removable'
    show_summary "$inst_auto_summary"

    if ! yesno install 'Proceed'; then
	exit 0
    fi

    ##################################################################
    ########################## installing ############################
    cat "$inst_summary" "$inst_auto_summary" |
    pkg_grep_summary -e FILE_NAME | sed -n 's/^PKGNAME=//p' |
    download_pkgs

    if test -n "$download_only"; then
	exit 0
    fi

    save_installed_packages

    if test -s "$rem_summary" -o -s "$extra_rem_summary"; then
	sed -n 's/^PKGNAME=//p' "$rem_summary" "$extra_rem_summary" \
	    > "$extra_rem_pkgs"
	pkg_summary2deps -drt "$installed_summary" | tsort |
	grep_lines "$extra_rem_pkgs" - | rev_lines |
	while read pkg; do
	    echo "Removing package $pkg..." 1>&2
	    $PKG_DELETE_CMD -f $pkg_opts "$pkg"
	done
    fi

    cd $CACHEDIR/All

    pkg_summary2deps -ndtr "$plan_summary" | tsort |
    while read pkg; do
	fn_auto_pkg=`pkg_grep_summary -r -s PKGNAME "$pkg" < "$inst_auto_summary" | summary2binary`
	fn_pkg=`pkg_grep_summary -r -s PKGNAME "$pkg" < "$inst_summary" | summary2binary`
	if test -n "$fn_auto_pkg"; then
	    echo "Installing package $pkg as a dependency..." 1>&2
	    if ! pkg_add $pkg_opts -UA "$fn_auto_pkg"; then
		cleanup_db; exit 1
	    fi
	elif test -n "$fn_pkg"; then
	    echo "Installing package $pkg..." 1>&2
	    if ! pkg_add $pkg_opts -U "$fn_pkg"; then
		cleanup_db; exit 1
	    fi
	fi
    done

    cleanup_db

    ##################################################################
    ###### Marking packages that were not installed or updated #######
    awk -v auto=0 '
	FILENAME != "-" && $0 ~ /^PKGNAME=/ {pkgname = substr($0, 9)}
	FILENAME != "-" && $0 ~ /^automatic/ {auto = 1}
	FILENAME != "-" && NF == 0 {hash_o [pkgname] = auto; auto = 0}
	FILENAME == "-" && $0 ~ /^PKGNAME=/ {pkgname = substr($0, 9)}
	FILENAME == "-" && $0 ~ /^automatic/ {auto = 1}
	FILENAME == "-" && NF == 0 {hash_n [pkgname] = auto; auto = 0}
	END {for (i in hash_n){
	    if ((i in hash_o) && hash_o [i] != hash_n [i])
		print i, hash_n [i]
	}}' "$installed_summary" - < "$plan_summary" |
    while read pkg m; do
	if test "$m" -eq 0; then
	    echo "Marking $pkg as installed by user"
	    $PKG_ADMIN_CMD unset automatic "$pkg"
	else
	    echo "Marking $pkg as installed as a dependency"
	    $PKG_ADMIN_CMD set automatic=yes "$pkg"
	fi
    done
    exit 0
fi

######################################################################
######################################################################
######################################################################
# uninstall | remove | delete
usage_uninstall (){
    cat <<'EOF'
nih uninstall <PKGBASEs>
nih delete    <PKGBASEs>
nih remove    <PKGBASEs>

      Remove specified packages, dependent packages and automatically installed
      leaf packages. These three command are the same.

   options:
      -h     display this help message
      -n     don't actually deinstall a package, just report the steps that
             would be taken if it were.

Examples:
   nih uninstall libgnome python26 kdelibs4
EOF
}

if test "_$1" = _uninstall -o "_$1" = _remove -o "_$1" = _delete; then
    shift
    while getopts hn f; do
	case "$f" in
	    '?')
		exit 1;;
	    n)
		pkg_delete_opts='-n';;
	    h)
		usage_uninstall
		exit 0;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    if test $# -eq 0; then
	echo 'Nothing to do' 1>&2
	exit 1
    fi
    pkg_info -I "$@" > "$tmp_dir/1" || true
    if ! test -s "$tmp_dir/1"; then
	echo 'Nothing to do' 1>&2
	exit 1
    fi
    awk '{print $1}' "$tmp_dir/1" > "$tmp_dir/2"

    echo 'The following packages will be removed:'
    indent "$tmp_dir/1"

    echo 'The following dependent packages will be removed:'
    pkg_bin_summary -f 'PKGNAME PKGPATH DEPENDS COMMENT' |
    tee "$tmp_dir/installed_summary" | pkg_summary2deps -nrd |
	pkg_subgraph_deps -xnf "$tmp_dir/2" > "$tmp_dir/4"
    pkg_grep_summary -S PKGNAME "$tmp_dir/4" < "$tmp_dir/installed_summary" |
    awk '/^PKGNAME=/ {pkgname=substr($0, 9)}
         /^COMMENT=/ {comment=substr($0, 9)}
         NF == 0 {printf "%-19s %s\n", pkgname, comment}' > "$tmp_dir/3"
    indent "$tmp_dir/3"

    if ! yesno remove_dep 'Remove them'; then
	exit 0
    fi

    save_installed_packages

    cat "$tmp_dir/4" "$tmp_dir/2" | xargs $PKG_DELETE_CMD $pkg_delete_opts

    cat <<'EOF'
The following packages were installed as auto-removed
and are no longer needed:
EOF
    pkg_status -l | tee "$tmp_dir/1" | indent -
    if ! yesno remove_auto 'Remove them'; then
	exit 0
    fi
    if yesno remove_auto_recurs 'Recursively'; then
	pkg_delete_opts="$pkg_delete_opts -A"
    fi
    awk '{print $1}' "$tmp_dir/1" | xargs $PKG_DELETE_CMD $pkg_delete_opts

    exit 0
fi

######################################################################
######################################################################
######################################################################
# verify
usage_verify (){
    cat <<'EOF'
nih verify [options] [PKGBASEs]

      Verify installed or listed packages.
      By default all installed packages are verified.

   options:
       -h     display this help message
       -m     check the checksums of installed files
       -l|-U  check the REQUIRES/PROVIDES coherence
       -L     check the existence of library files listed in REQUIRES
       -d     check the presence of dependencies
       -c     check the conflicts
Examples:
   nih verify -dclL
   nih verify -m
   nih verify -m 'lib*' gawk
EOF
}

if test "$1" = verify; then
    shift
    opts='k'
    while getopts hmUlLdc f; do
	case "$f" in
	    '?')
		exit 1;;
	    h)
		usage_verify
		exit 0;;
	    l)
		opts="${opts}U";;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    if test k = "$opts"; then
	echo 'Nothing to do' 1>&2
	exit 1
    fi

    pkg_status "-$opts" "$@"

    exit 0
fi

######################################################################
######################################################################
######################################################################
# status
usage_status (){
    cat <<'EOF'
nih status [options] [PKGBASEs]

      Compare installed packages with pkg_summary.txt (default) or
      pkgsrc tree.

   options:
      -h     display this help message
      -b     compare installed packages against pkg_summary.txt (default)
      -s     compare installed packages against pkgsrc tree
      -r     raw output (pkg_summary format)
      -u     analyse packages marked as installed by user (the default, see -a)
      -a     analyse all packages (see -u)
      -B     consider packages different if their BUILD_DATE differ
      -A     by default up-to-date packages are skipped,
             with -A they are output too
      -q     no noisy reminder about output format

Examples:
   nih status -a
   nih status -uq
   nih status -sqr pkglint
EOF
}

if test "$1" = status; then
    shift
    opts='b'
    while getopts hbsruaqAB f; do
	case "$f" in
	    '?')
		exit 1;;
	    h)
		usage_status
		exit 0;;
	    a)
		opts="${opts}aT";;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    if echo "$opts" | grep 'b[^s]*$' > /dev/null; then
	refresh_summary
    fi

    pkg_status "-$opts" "$@"

    exit 0
fi

######################################################################
######################################################################
######################################################################
# search
usage_search (){
    cat <<'EOF'
nih search [options] [args]

      Search for packages

   option:
      -h    display this help message

      -b    search in pkg_summary.txt (the default)
      -o    search using pkg_online
      -I    search in installed packages

      -s    output search strategies
      -f    output search fields
      -1    display 1-line information about packages (default)
      -3    display short information about packages
      -9    display full information about packages
      -r    raw output in pkg_summary(5) format
      -q    quiet mode, do not print "No matches found" to stderr

See pkg_digger(1) for details.

Examples:
   nih search -h
   nih search -s
   nih search -f
   nih search DEPENDS:substring:libmaa
   nih search PKGNAME:prefix:dict
   nih search COMMENT:word:dns PKGPATH:prefix:net
   nih search c:kw:'dns server'
   nih search n:p:lua
   nih search FILE_SIZE:awk:'fvalue+0 > 100000000'
   nih search -9 lang/mawk
   nih search -os
   nih search -of
   nih search -o oberon
   nih search -o dns server
   nih search -o3 dictionary -spell -japanese -chinese -korean
   nih search -o -q9r spreadsheet
EOF
}

# info
usage_info (){
    cat <<'EOF'
nih info [options] [PKGBASEs]

      Show information about packages

   option:
      -h    display this help message

      -b    search in pkg_summary.txt (the default)
      -o    search using pkg_online
      -I    search in installed packages

      -r    raw output in pkg_summary(5) format
      -q    quiet mode, do not print "No matches found" to stderr

See pkg_digger(1) for details.

Examples:
   nih info -h
   nih info runawk
   nih info -I runawk
   nih info -o oberon
EOF
}

if test "_$1" = _search -o "_$1" = _info; then
    op="$1"
    shift
    export PKG_DIGGER_SUMMARY="$PKG_SUMMARY"

    while getopts hboIsf139rq f; do
	case "$f" in
	    '?')
		exit 1;;
	    b)
		unset PKG_DIGGER_BACKEND || true
		unset in_installed || true;;
	    o)
		export PKG_DIGGER_BACKEND=pkg_online_client
		unset in_installed || true;;
	    I)
		unset PKG_DIGGER_BACKEND || true
		in_installed=1;;
	    h)
		usage_$op
		exit 0;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    if test -n "$in_installed"; then
	export PKG_DIGGER_SUMMARY="$tmp_dir/installed_summary"
	pkg_bin_summary -a automatic > "$PKG_DIGGER_SUMMARY"
    fi

    if test "$PKG_DIGGER_SUMMARY" = "$PKG_SUMMARY" -a \
	"$PKG_DIGGER_BACKEND" = ''
    then
	summary_exists
    fi

    if test "$op" = info; then
	for i in "$@"; do
	    pkg_digger -9 ${opts+-$opts} PKGBASE:exact:"$i"
	done
    else
	pkg_digger ${opts+-$opts} "$@"
    fi

    exit 0
fi

######################################################################
######################################################################
######################################################################
# leaf
usage_leaf (){
    cat <<'EOF'
nih leaf [options]

      Output or remove automatically installed leaf packages,
      by default list of leaves is output.

   option:
      -h    display this help message
      -t    output only PKGNAME
      -R    remove automatically installed leaf packages
      -E    remove automatically installed leaf packages recursively
      -n    pass -n to pkg_delete

Examples:
   nih leaf -t
   nih leaf -R
   nih leaf -En
EOF
}

if test "$1" = leaf; then
    shift
    opts='l'
    while getopts htREn f; do
	case "$f" in
	    '?')
		exit 1;;
	    h)
		usage_leaf
		exit 0;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    if echo "$opts" | awk 'BEGIN { exit (!/[RE]/ || /n/) }' > /dev/null; then
	save_installed_packages
    fi

    save_installed_packages
    pkg_status "-$opts" "$@"

    exit 0
fi

######################################################################
######################################################################
######################################################################
# list
if test "$1" = list; then
    echo 'Not implemented yet' 1>&2
    exit 1
fi

######################################################################
######################################################################
######################################################################
# mark
usage_mark (){
    cat <<'EOF'
nih mark [options] PKGBASEs

      Mark packages

   option:
      -h    display this help message
      -u    mark packages as installed by user
      -a    mark packages as auto-removable

Examples:
   nih mark -a libmaa
   nih mark -u pkg_status
EOF
}

if test "$1" = mark; then
    shift
    opts='l'
    while getopts hua f; do
	case "$f" in
	    '?')
		exit 1;;
	    h)
		usage_mark
		exit 0;;
	    u)
		mode_u=1;;
	    a)
		mode_a=1;;
	    *)
		opts="${opts}$f";;
	esac
    done
    shift `expr $OPTIND - 1`

    if test "$mode_u$mode_a" = 11; then
	echo '-u and -d options are exclusive' 1>&2
	exit 1
    elif test -z "$mode_u$mode_a"; then
	echo 'Either -u or -d must be applied' 1>&2
	exit 1
    elif test -n "$mode_a"; then
	cmd='set automatic=yes'
    else
	cmd='unset automatic'
    fi

    if test $# -eq 0; then
	echo 'No packages were specified' 1>&2
	exit 
    fi

    $PKG_ADMIN_CMD $cmd "$@"
    exit 0
fi

######################################################################
######################################################################
######################################################################
# deps
usage_deps (){
    cat <<'EOF'
nih deps [options] [pkgs...]

      Output a dependency graph of installed packages or remote summary.

   option:
      -h    display this help message
      -r    output dependencies, by default packages
            that depend on "pkgs" are output.
      -l    output list of packages instead of graph
      -B    output PKGBASE (the default)
      -P    output PKGPATH
      -N    output PKGNAME
      -t    output dependencies in tsort(1) compatible format
      -I    analyse installed packages
If both -P and -N are applied, PKGPATH;PKGNAME is output,
if both -P and -B are applied, PKGPATH;PKGBASE is output.

Examples:
   nih deps
   nih deps -P
   nih deps -PB
   nih deps glib2
   nih deps -r glib2
   nih deps -rI pkgnih
   nih deps -lBP 'devel/glib2;glib2' 'devel/libmaa;libmaa'
   nih deps -P devel/glib2 devel/libmaa
EOF
}

if test "$1" = deps; then
    shift
    sb_opts=''
    pn_opts=''
    while getopts hrlBNPtI f; do
	case "$f" in
	    '?')
		exit 1;;
	    h)
		usage_deps
		exit 0;;
	    r)
		sb_opts="$sb_opts -r";;
	    l)
		sb_opts="$sb_opts -n";;
	    t)
		pn_opts="$pn_opts -t";;
	    B)
		pn_opts="$pn_opts -n";;
	    N)
		pn_opts="$pn_opts -nr";;
	    P)
		pn_opts="$pn_opts -p";;
	    I)
		installed_summary=1;;
	esac
    done
    shift `expr $OPTIND - 1`

    pn_opts=${pn_opts:--n}

    if test -n "$installed_summary"; then
	pkg_bin_summary -fPKGNAME,PKGPATH,DEPENDS
    else
	summary_exists
	cat "$PKG_SUMMARY"
    fi |
    pkg_summary2deps -d $pn_opts |
    if test $# -eq 0; then
	sort -u
    else
	pkg_subgraph_deps $sb_opts -p "$*" | sort -u
    fi
    exit 0
fi

######################################################################
######################################################################
######################################################################
# license
if test "$1" = license; then
    echo 'Not implemented yet' 1>&2
    exit 1
fi

######################################################################
######################################################################
######################################################################
# clean-cache
usage_clean_cache (){
    cat <<'EOF'
nih clean-cache [options] [pkgs...]

      Delete binaries in cache directory. By default all binaries
      except those of installed packages are removed.

   option:
      -h    display this help message
      -n    output files to be deleted
      -a    remove all binaries
      -i    binaries for packages listed in ~/.nih/installed_*.txt
            are not removed.

Examples:
   nih clean-cache
   nih clean-cache -n
   nih clean-cache -a
EOF
}

if test "$1" = clean-cache; then
    shift
    while getopts hnai f; do
	case "$f" in
	    '?')
		exit 1;;
	    h)
		usage_clean_cache
		exit 0;;
	    n)
		noop=1;;
	    a)
		rem_all=1;;
	    i)
		keep_installed=1;;
	esac
    done
    shift `expr $OPTIND - 1`

    cd $CACHEDIR/All

    present=$tmp_dir/present
    installed=$tmp_dir/installed
    del=$tmp_dir/del

    if test -n "$rem_all"; then
	printf '' > "$installed"
    else
	{
	    pkg_info -Xa

	    if test -n "$keep_installed"; then
		find "$confdir" -name 'installed_*.txt' | xargs cat
	    fi
	} | summary2binary | sort -u > "$installed"
    fi

    eval "ls -1 *$SUFX" | sort > "$present"

    echo 'The following files will be deleted'
    comm -13 "$installed" "$present" > "$del"
    indent "$del"
    if test -n "$noop" || ! yesno remove_pkgs 'Proceed'; then
	exit 0
    fi

    xargs rm -f < "$del"

    exit 0
fi

######################################################################
######################################################################
######################################################################
# <bad> command
echo "Unknown command '$1', see nih -h for more information" 1>&2
exit 2
