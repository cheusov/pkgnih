#!/usr/bin/env runawk

# Copyright (c) 2010, Aleksey Cheusov <vle@gmx.net>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials provided
#       with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#env "LC_ALL=C"

#use "power_getopt.awk"
#use "xgetline.awk"
#use "tmpfile.awk"
#use "shquote.awk"
#use "xclose.awk"
#use "xsystem.awk"
#use "psu_funcs.awk"
#use "pkgsrc-dewey.awk"

#.begin-str help
# Usage: pkg_update_plan <inst_summary> <avail_summary> PKGPATHs...
# OPTIONS:
#   -h        display this help
#   -v        verbose mode
#   -i        obtains packages from stdin
#.end-str

BEGIN {
	if (getarg("h")){
		print_help()
		exitnow(0)
	}
	verbose_mode = getarg("v")
	from_stdin   = getarg("i")

	if (ARGC < 3 - from_stdin){
		exit 45
	}

	inst_summary  = ARGV [1]
	avail_summary = ARGV [2]
	ARGV [2] = ""
	ARGV [1] = "-"
}

############################################################
# preparations
function process_pkg (pkg,            base,pref){
	match(pkg, /^[-+*?]/)
	pref = substr(pkg, 1, RLENGTH)
	base = substr(pkg, 1 + RLENGTH)

	if (pref == "*"){
		pref = "+"
	}

	if (pref == "-"){
		if (base in inst_base2pair){
			pair = inst_base2pair [base]
		}else if (base in inst_name2pair){
			pair = inst_name2pair [base]
		}else if (base in inst_path2pair){
			pair = inst_path2pair [base]
		}else if (!index(base, ",")){
			print pkg " cannot be found" > "/dev/stderr"
			ex = 1
		}
	}else{
		if (base in avail_base2pair){
			pair = avail_base2pair [base]
		}else if (base in avail_name2pair){
			pair = avail_name2pair [base]
		}else if (base in avail_path2pair){
			pair = avail_path2pair [base]
		}else if (!index(base, ",")){
			print pkg " cannot be found" > "/dev/stderr"
			ex = 1
		}
	}

	if (ex)
		return

	if (pref == "?"){
		if (!(pair in inst_pair2auto) || inst_pair2auto [pair])
			pref = "+"
		else
			pref = ""
	}

	if (pref == "-"){
		rem_pkgs [pair] = 0
	}else if (pref == "+"){
		delete add_pkgs [pair]
		add_auto_pkgs [pair] = 0
		rem_pkgs [pair] = 0
		add_base [base] = 0
	}else{
		delete add_auto_pkgs [pair]
		add_pkgs [pair] = 0
		rem_pkgs [pair] = 0
		add_base [base] = 0
	}
}

############################################################
# reading and analysing installed and available summaries
BEGIN {
	auto = 0
	while (xgetline0(inst_summary)){
		if ($0 ~ /^PKGNAME=/){
			pkgname = substr($0, 9)
		}else if ($0 ~ /^PKGPATH=/){
			pkgpath = substr($0, 9)
		}else if ($0 ~ /^automatic=/){
			auto = (substr($0, 11) != "")
		}else if (NF == 0){
			pkgbase = pkgname
			sub(/-[^-]*$/, "", pkgbase)
			pkgpair = (pkgpath "," pkgbase)

			inst_name2pair [pkgname] = pkgpair
			inst_base2pair [pkgbase] = pkgpair
			inst_path2pair [pkgpath] = pkgpair
			inst_pair2auto [pkgpair] = auto

			pkgname = pkgpath = ""
			auto = 0
		}
	}
	xclose(inst_summary)

	while (xgetline0(avail_summary)){
		if ($0 ~ /^PKGNAME=/){
			pkgname = substr($0, 9)
		}else if ($0 ~ /^PKGPATH=/){
			pkgpath = substr($0, 9)
		}else if (NF == 0){
			pkgbase = pkgname
			sub(/-[^-]*$/, "", pkgbase)
			pkgpair = (pkgpath "," pkgbase)

			if (pkgbase in inst_base2pair){
				if (inst_base2pair [pkgbase] == pkgpair)
					avail_base2pair [pkgbase] = pkgpair
			}else if (! (pkgbase in avail_base2pair) ||
					  pkgname_gt_pkgname(pkgname, avail_base2name [pkgbase]))
			{
				avail_base2pair [pkgbase] = pkgpair
			}
			avail_name2pair [pkgname] = pkgpair
			avail_path2pair [pkgpath] = pkgpair

			pkgname = pkgpath = ""
		}
	}
	xclose(avail_summary)
}

BEGIN {
	update_pkgpath_list = ""
	if (from_stdin){
		while (xgetline0()){
			process_pkg($1)
		}
	}else{
		for (i=(ARGV [3] == "--" ? 4 : 3); i < ARGC; ++i){
			process_pkg(ARGV [i])
		}
	}

	if (ex)
		exitnow(ex)

#	show_progress()
#	exit 13
}

############################################################
function grep_package_cmd (package, field){
	return "pkg_grep_summary -r -fPKGNAME,PKGPATH,DEPENDS,CONFLICTS,COMMENT -t strlist " \
		field " " shquote(package)
}

function rm (file){
	xsystem("rm " shquote(file))
}

function rem_packages_from_summary (input, output,             pkgs,cmd){
	pkgs = hash_to_indices(rem_pkgs)

	assert(pkgs != "")

	# remove specified packages from inst_summary
	cmd = "pkg_grep_summary -v -t strlist PKGPAIR '" pkgs "' < " \
		shquote(input) " > " output
	system(cmd)
}

function create_packages_summary (output, hash,                  pkgs,cmd)
{
	pkgs = hash_to_indices(hash)

	cmd = grep_package_cmd(pkgs, "PKGPAIR") \
		" < " shquote(avail_summary) " > " output
	system(cmd)
}

function hash_to_indices (hash,           i,ret){
	ret = ""
	for (i in hash){
		if (ret == "")
			ret = i
		else
			ret = ret " " i
	}
	return ret
}

function generate_plan (output,           tmpfn,ii,s1)
{
	s1 = tmpfile()
	rem_packages_from_summary(inst_summary, s1)

	for (ii in add_pkgs){
		# add specified packages to inst_summary
		tmpfn = tmpfile()
		create_packages_summary(tmpfn, add_pkgs)

		system("cat " tmpfn " >> " s1)
		rm(tmpfn)
		break
	}

	for (ii in add_auto_pkgs){
		# add specified packages as dependencies to inst_summary
		tmpfn = tmpfile()
		create_packages_summary(tmpfn, add_auto_pkgs)

		system("awk 'NF == 0 {print \"automatic=yes\"} {print}' " tmpfn " >> " s1)
		rm(tmpfn)
		break
	}

	cmd = "pkg_summary2leaves -vra " s1 " > " output
	system(cmd)
	rm(s1)
}

function get_imghash (){
	return length(hash_to_indices(rem_pkgs)) " " length(hash_to_indices(add_pkgs)) " " length(hash_to_indices(add_auto_pkgs))
}

function show_progress (){
	if (verbose_mode){
		printf "    R:%d U:%d A:%d\n", length(rem_pkgs), length(add_pkgs),
			length(add_auto_pkgs) > "/dev/stderr"
		if (verbose_mode > 1){
			printf "rem_pkgs:" > "/dev/stderr"
			for (i in rem_pkgs){
				printf " %s", i > "/dev/stderr"
			}
			printf "\n" > "/dev/stderr"

			printf "add_pkgs:" > "/dev/stderr"
			for (i in add_pkgs){
				printf " %s", i > "/dev/stderr"
			}
			printf "\n" > "/dev/stderr"

			printf "add_auto_pkgs:" > "/dev/stderr"
			for (i in add_auto_pkgs){
				printf " %s", i > "/dev/stderr"
			}
			printf "\n" > "/dev/stderr"
		}
	}
}

BEGIN {
	planfn = tmpfile()
	errfn  = tmpfile()
	errfn2 = tmpfile()

	old_imghash = get_imghash()

	while (1){
		show_progress()

		generate_plan(planfn)
		cmd = "pkg_lint_summary -dcul " planfn " > " errfn
		if (!system(cmd))
			break

		ex = 0
		while (xgetline0(errfn)){
			ex2 = 0
			if ($1 == "d:" && $2 == "not_found"){
				pkgbase = pkgname2pkgbase($6)
				depbase = pkgname2pkgbase($3)

				if (pkgbase in add_base){
					process_pkg("?" depbase)
				}else if (depbase in add_base){
					process_pkg("?" pkgbase)
				}else{
					ex = ex2 = 1
				}
			}else if ($1 == "c:" && $2 == "conflict"){
				pkgbase = pkgname2pkgbase($8)
				cnfbase = pkgname2pkgbase($5)

				if ((pkgbase in add_base) && !(cnfbase in add_base)){
					process_pkg(cnfbase)
				}else{
					ex = ex2 = 1
				}
			}else{
				ex = ex2 = 1
			}

			if (ex2)
				print $0 > errfn2
		}
		xclose(errfn)
		close(errfn2)

		if (ex)
			break

		new_imghash = get_imghash()
		if (old_imghash == new_imghash){
			break
		}

		old_imghash = new_imghash
	}

	show_progress()

	if (ex){
		system("cat " errfn2)
		if (verbose_mode > 1){
			system("cat " planfn " 1>&2")
		}
		exitnow(1)
	}else{
		exitnow(system("cat " planfn))
	}
}
