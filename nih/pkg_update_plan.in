#!/usr/bin/env runawk

# Copyright (c) 2010, Aleksey Cheusov <vle@gmx.net>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials provided
#       with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#env "LC_ALL=C"

#use "power_getopt.awk"
#use "xgetline.awk"
#use "tmpfile.awk"
#use "shquote.awk"
#use "xclose.awk"
#use "xsystem.awk"
#use "psu_funcs.awk"

#.begin-str help
# Usage: pkg_update_plan <inst_summary> <avail_summary> PKGPATHs...
# OPTIONS:
#   -h        display this help
#   -v        verbose mode
#.end-str

BEGIN {
	if (getarg("h")){
		print_help()
		exitnow(0)
	}
	verbose_mode = getarg("v")

	if (ARGC < 3){
		exit 45
	}

	inst_summary  = ARGV [1]
	avail_summary = ARGV [2]

	deps_graph = tmpfile()
}

############################################################
# preparations
BEGIN {
	update_pkgpath_list = ""
	for (i=3; i < ARGC; ++i){
		pkg = ARGV [i] # PKGPATH
		if (pkg ~ /^-/){
			rem_pkgs [substr(pkg, 2)] = 0
		}else if (pkg ~ /^[+*]/){
			add_auto_pkgs [substr(pkg, 2)] = 0
			rem_pkgs [substr(pkg, 2)] = 0
		}else{
			add_pkgs [pkg] = 0
			rem_pkgs [pkg] = 0
		}
	}
}

############################################################
# converting PKGPATHs of upgraded packages to PKGNAMEs
# BEGIN {
# 	# updatable PKGPATH to PKGNAME
# 	pipe = "pkg_grep_summary -t strlist PKGPATH '" \
# 		update_pkgpath_list "' < " shquote(avail_summary)
# 	while ((pipe | getline) > 0){
# 		if ($0 ~ /^PKGNAME=/){
# 			pkgname = substr($0, 9)
# 		}else if ($0 ~ /^PKGPATH=/){
# 			pkgpath = substr($0, 9)
# 		}else if (NF == 0){
# #			print pkgpath, pkgname
# 			update_pkgpath2pkgname [pkgpath] = pkgname
# 			pkgpath = pkgname = ""
# 		}
# 	}
# 	xclose(pipe)
# }

############################################################
# reading and analysing installed and available summaries
BEGIN {
	auto = 0
	while (xgetline0(inst_summary)){
		if ($0 ~ /^PKGNAME=/){
			pkgname = substr($0, 9)
		}else if ($0 ~ /^PKGPATH=/){
			pkgpath = substr($0, 9)
		}else if ($0 ~ /^automatic=/){
			auto = (substr($0, 11) != "")
		}else if (NF == 0){
			pkgbase = pkgname
			sub(/-[^-]*$/, "", pkgbase)
#			inst_base2name [pkgbase] = pkgname
			inst_base2auto [pkgbase] = auto
			inst_base2path [pkgbase] = pkgpath

			pkgname = pkgpath = ""
			auto = 0
		}
	}
	xclose(inst_summary)
}

# 	while (xgetline0(avail_summary)){
# 		if ($0 ~ /^PKGNAME=/){
# 			pkgname = substr($0, 9)
# 		}else if ($0 ~ /^PKGPATH=/){
# 			pkgpath = substr($0, 9)
# 		}else if (NF == 0){
# 			pkgbase = pkgname
# 			sub(/-[^-]*$/, "", pkgbase)
# 			avail_name2base [pkgname] = pkgbase
# 			avail_name2path [pkgname] = pkgpath

# 			pkgname = pkgpath = ""
# 		}
# 	}
# 	xclose(avail_summary)
# }

############################################################
function grep_package_cmd (package, field){
	return "pkg_grep_summary -r -fPKGNAME,PKGPATH,DEPENDS,CONFLICTS,COMMENT -t strlist " \
		field " " shquote(package)
}

function rm (file){
	xsystem("rm " shquote(file))
}

function ensure_pkgs_exist (pkgs, filename,                i,arr,hash,cnt,name){
	cnt = split(pkgs, arr)
	for (i=1; i <= cnt; ++i){
		hash [arr [i]] = 0
	}

	while (xgetline0(filename)){
		if (/^PKGNAME=/){
			name = substr($0, 9)
			delete hash [name]
			sub(/-[^-]*$/, "", name)
			delete hash [name]
		}else if (/^PKGPATH=/){
			name = substr($0, 9)
			delete hash [name]
		}
	}
	xclose(filename)
 
	for (i in hash){
		if (!failed)
			print "The following packages cannot be found" > "/dev/stderr"
		break
	}
	for (i in hash){
		print "   " i > "/dev/stderr"
	}
	for (i in hash){
		failed = 1
		break
	}
}

function rem_packages_from_summary (input, output,             pkgs,cmd){
	pkgs = hash_to_indices(rem_pkgs)

	if (pkgs != ""){
		# remove specified packages from inst_summary
		cmd = "pkg_grep_summary -v -t strlist PKGPATH '" pkgs "' < " \
			shquote(input) \
			" | pkg_grep_summary -v -t strlist PKGNAME '" pkgs "'" \
			" | pkg_grep_summary -v -t strlist PKGBASE '" pkgs "'" \
			" > " output
		system(cmd)
	}else{
		system("cp " shquote(input) " " output)
	}
}

function create_packages_summary (output, hash,                  pkgs,cmd)
{
	pkgs = hash_to_indices(hash)
	cmd = grep_package_cmd(pkgs, "PKGBASE") \
		" < " shquote(avail_summary) " > " output
	system(cmd)

	cmd = grep_package_cmd(pkgs, "PKGPATH") \
		" < " shquote(avail_summary) " >> " output
	system(cmd)

	cmd = grep_package_cmd(pkgs, "PKGNAME") \
		" < " shquote(avail_summary) " >> " output
	system(cmd)
}

function hash_to_indices (hash,           i,ret){
	ret = ""
	for (i in hash){
		if (ret == "")
			ret = i
		else
			ret = ret " " i
	}
	return ret
}

function generate_plan (output,           tmpfn,ii,s1)
{
	s1 = tmpfile()
	rem_packages_from_summary(inst_summary, s1)

	for (ii in add_auto_pkgs){
		# add specified packages as dependencies to inst_summary
		tmpfn = tmpfile()
		create_packages_summary(tmpfn, add_auto_pkgs)
		ensure_pkgs_exist(hash_to_indices(add_auto_pkgs), tmpfn)

		system("awk 'NF == 0 {print \"automatic=yes\"} {print}' " tmpfn " >> " s1)
		rm(tmpfn)
		break
	}

	for (ii in add_pkgs){
		# add specified packages to inst_summary
		tmpfn = tmpfile()
		create_packages_summary(tmpfn, add_pkgs)
		ensure_pkgs_exist(hash_to_indices(add_pkgs), tmpfn)

		system("cat " tmpfn " >> " s1)
		rm(tmpfn)
		break
	}
	if (failed)
		exitnow(12)

	cmd = "pkg_summary2leaves -vra " s1 " > " output
	system(cmd)
	rm(s1)
}

function get_imghash (){
	return length(hash_to_indices(rem_pkgs)) " " length(hash_to_indices(add_pkgs)) " " length(hash_to_indices(add_auto_pkgs))
}

function show_progress (){
	if (verbose_mode){
		printf "    R:%d U:%d A:%d\n", length(rem_pkgs), length(add_pkgs),
			length(add_auto_pkgs) > "/dev/stderr"
	}
}

BEGIN {
	planfn = tmpfile()
	errfn  = tmpfile()

	old_imghash = get_imghash()

	while (1){
		show_progress()

		generate_plan(planfn)
		cmd = "pkg_lint_summary -dcu " planfn " > " errfn
		ex = system(cmd)
		if (!ex)
			break

		while (xgetline0(errfn)){
			if ($1 == "d:" && $2 == "not_found"){
				reqd = pkgname2pkgbase($3)
				if (! (reqd in inst_base2path))
					add_auto_pkgs [reqd] = 0
				else{
					reqd_path = inst_base2path [reqd]
					if (inst_base2auto [reqd])
						add_auto_pkgs [reqd_path] = 0
					else
						add_pkgs [reqd_path] = 0
				}
				rem_pkgs [reqd] = 0
			}else{
				ex = 1
				break
			}
		}
		xclose(errfn)

		if (ex)
			break

		new_imghash = get_imghash()
		if (old_imghash == new_imghash){
			break
		}

		old_imghash = new_imghash
	}

	show_progress()

	if (ex){
		system("cat " errfn)
		exitnow(1)
	}else{
		exitnow(system("cat " planfn))
	}
}
